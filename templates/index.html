<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>祖宇字文共享</title>
    <link rel="stylesheet" href="/static/style.css">
    <!-- 移除Socket.IO库，使用原生WebSocket -->
</head>
<body>
<!-- 客服模板菜单 -->
<div class="template-sidebar" id="templateSidebar">
    <div class="sidebar-header">
        <h3>💬 菜单栏目</h3>
        <button class="close-btn mobile-only" onclick="toggleTemplateSidebar()">×</button>
    </div>
    <div class="sidebar-content">
        <div class="category-menu" id="categoryMenu">
            <!-- 分类菜单将由JavaScript动态加载 -->
        </div>
        
        <!-- 服务器信息和二维码区域 -->
        <div class="sidebar-footer">
            <!-- 扫码访问区域（置于上方） -->
            <div class="qr-section-sidebar">
                <div class="qr-header-sidebar">
                    <h4>📱 扫码访问</h4>
                </div>
                
                <div class="qr-content-sidebar" id="sidebar-qr-content">
                    <div class="qr-image-container-sidebar">
                        <img id="sidebarQrImage" alt="二维码" class="qr-image-sidebar" 
                             onload="console.log('✅ 侧边栏二维码加载成功!'); console.log('🔍 二维码数据长度:', this.src.length);" 
                             onerror="console.log('❌ 侧边栏二维码加载失败!'); console.log('🔍 失败的二维码数据:', this.src); this.parentNode.innerHTML='<p class=error>二维码生成失败</p>'" />
                    </div>
                </div>
            </div>
            
            <!-- 服务器信息区域（置于下方） -->
            <div class="server-info-sidebar">
                <h4>📡 服务器信息</h4>
                <div class="server-url-display">{{.server_url}}</div>
                <button onclick="copySidebarUrl()" class="copy-sidebar-btn">
                    📋 复制地址
                </button>
            </div>
        </div>
    </div>
</div>

<!-- 主内容区域 -->
<div class="main-content" id="mainContent">
    <!-- 移动端菜单按钮 -->
    <button class="mobile-menu-btn" id="mobileMenuBtn" onclick="toggleTemplateSidebar()">
        💬 菜单栏目
    </button>
    
    <!-- 共享文字界面 -->
    <div class="interface-container" id="textShareInterface">
        <div class="container">
            <h2>
                📝 祖宇字文共享
                <span id="connection-status" class="connection-status">🔴 连接中...</span>
                <button id="reconnect-btn" class="reconnect-btn" onclick="manualReconnect()" style="display: none;">🔄 重连</button>
                <span id="network-type" class="network-type">🌐 {{.network_type}}</span>
            </h2>
            
            <!-- 主要输入区域 -->
            <div class="input-section">
                <h3>✍️ 添加文字内容</h3>
                <textarea id="content" 
                          placeholder="在这里输入或粘贴文字内容...&#10;💡 电脑端按回车键快速提交" 
                          onkeydown="handleKeyPress(event)"></textarea>
                <button onclick="addMessage()" class="submit-btn">📤 提交内容</button>
            </div>
            
            <!-- 消息列表区域 -->
            <div class="messages-section">
                <div class="messages-header">
                    <h3>📋 已保存的内容</h3>
                    <button onclick="showUploadModal()" class="upload-btn" title="发送文件">
                        📤 发送文件
                    </button>
                </div>
                
                <!-- 文件传输通知区域 - 置顶显示 -->
                <div class="file-notifications" id="fileNotifications" style="display: none;">
                    <h4>📁 文件传输通知</h4>
                    <div id="fileNotificationsList" class="file-notifications-list">
                        <!-- 文件通知将在这里显示 -->
                    </div>
                </div>
                
                <div id="messages">
                    {{range .messages}}
                    <div class="message" data-time="{{.Time}}">
                        <div class="message-header">
                            <div class="message-footer">
                                <span class="time">⏰ {{.Time}}</span>
                                <div class="message-actions">
                                    <button onclick="deleteMessage(this)" class="delete-btn">🗑️ 删除</button>
                                    <button onclick="addMessageToTemplate(this)" class="add-to-template-btn">➕ 添加到栏目</button>
                                    <button onclick="copyMessage(this)" class="copy-btn large-copy-btn">📋 复制</button>
                                </div>
                            </div>
                            <div class="content">{{.Content}}</div>
                        </div>
                    </div>
                    {{end}}
                </div>
            </div>
            
            <!-- 二维码区域（放在底部） -->
            <div class="qr-section" id="qr-section">
                <div class="qr-header">
                    <h3>📱 扫码快速访问</h3>
                    <button onclick="toggleQR()" id="toggle-btn" class="toggle-btn">
                        👀 显示二维码
                    </button>
                </div>
                
                <div class="qr-content" id="qr-content" style="display: none;">
                    <div class="server-info">
                        <p><strong>服务器地址：</strong></p>
                        <div class="url-display">{{.server_url}}</div>
                        <button onclick="copyMainUrl()" class="copy-url-btn">
                            📋 复制地址
                        </button>
                    </div>
                    
                    <div class="qr-image-container">
                        <img id="mainQrImage" alt="二维码" class="qr-image" 
                             onload="console.log('✅ 二维码加载成功!'); console.log('🔍 主二维码数据长度:', this.src.length);" 
                             onerror="console.log('❌ 二维码加载失败!'); console.log('🔍 失败的二维码数据:', this.src); this.parentNode.innerHTML='<p class=error>二维码生成失败</p>'" />
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 其他界面 -->
    <!-- 售前问题界面 -->
    <div class="interface-container" id="presaleInterface" style="display: none;">
        <div class="container">
            <h2>💬 售前问题</h2>
            <div class="template-content-area">
                <div id="presaleTemplates" class="template-display-area">
                    <!-- 售前模板将在这里显示 -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- 快递问题界面 -->
    <div class="interface-container" id="expressInterface" style="display: none;">
        <div class="container">
            <h2>📦 快递问题</h2>
            <div class="template-content-area">
                <div id="expressTemplates" class="template-display-area">
                    <!-- 快递模板将在这里显示 -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- 售后问题界面 -->
    <div class="interface-container" id="aftersaleInterface" style="display: none;">
        <div class="container">
            <h2>🛠️ 售后问题</h2>
            <div class="template-content-area">
                <div id="aftersaleTemplates" class="template-display-area">
                    <!-- 售后模板将在这里显示 -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- 购买链接界面 -->
    <div class="interface-container" id="purchaseInterface" style="display: none;">
        <div class="container">
            <h2>🛒 购买链接</h2>
            <div class="template-content-area">
                <div id="purchaseTemplates" class="template-display-area">
                    <!-- 购买链接模板将在这里显示 -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- 维修问题界面 -->
    <div class="interface-container" id="repairInterface" style="display: none;">
        <div class="container">
            <h2>🔧 维修问题</h2>
            <div class="template-content-area">
                <div id="repairTemplates" class="template-display-area">
                    <!-- 维修问题模板将在这里显示 -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- 系统设置界面 -->
    <div class="interface-container" id="settingsInterface" style="display: none;">
        <div class="container">
            <h2>⚙️ 系统设置</h2>
            <div class="settings-content-area">
                <!-- 添加内容功能区域 -->
                <div class="add-content-section">
                    <h3>➕ 添加内容</h3>
                    
                    <div class="add-content-form">
                        <div class="form-group">
                            <label for="categorySelect">选择栏目：</label>
                            <select id="categorySelect" class="form-select">
                                <!-- 栏目选项将由JavaScript生成 -->
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="templateTitle">模板标题：</label>
                            <input type="text" id="templateTitle" class="form-input" placeholder="请输入模板标题...">
                        </div>
                        
                        <div class="form-group">
                            <label for="templateContent">模板内容：</label>
                            <textarea id="templateContent" class="form-textarea" rows="4" placeholder="请输入模板内容..."></textarea>
                        </div>
                        
                        <div class="form-actions">
                            <button onclick="addNewTemplate()" class="action-btn add-btn">
                                ➕ 添加模板
                            </button>
                            <button onclick="clearAddForm()" class="action-btn clear-btn">
                                🗑️ 清空表单
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- 管理现有内容功能区域 -->
                <div class="manage-content-section">
                    <div class="manage-header">
                        <h3>📋 管理现有内容</h3>
                        <button onclick="clearAllTemplates()" class="action-btn clear-all-btn" title="删除所有栏目的所有模板">
                            🗑️ 删除所有内容
                        </button>
                    </div>
                    
                    <div class="manage-controls">
                        <div class="form-group">
                            <label for="manageCategorySelect">选择栏目：</label>
                            <select id="manageCategorySelect" class="form-select" onchange="loadCategoryTemplates()">
                                <option value="">请选择栏目...</option>
                                <!-- 栏目选项将由JavaScript生成 -->
                            </select>
                        </div>
                        
                        <!-- 单个栏目删除按钮（初始隐藏） -->
                        <div id="categoryDeleteContainer" class="category-delete-container" style="display: none;">
                            <button onclick="clearCategoryTemplates()" class="action-btn clear-category-btn">
                                🗑️ 删除本栏目所有内容
                            </button>
                        </div>
                    </div>
                    
                    <div id="templatesList" class="templates-list">
                        <div class="no-selection">请选择栏目查看其中的模板</div>
                    </div>
                </div>
                
                <!-- 导入导出功能区域 -->
                <div class="import-export-section">
                    <h3>📦 数据管理</h3>
                    
                    <!-- 导出功能 -->
                    <div class="export-section">
                        <h4>📤 导出数据</h4>
                        <div class="export-options">
                            <div class="option-group">
                                <label>导出格式：</label>
                                <div class="radio-group">
                                    <input type="radio" id="exportTxt" name="exportFormat" value="txt" checked>
                                    <label for="exportTxt">TXT文本格式</label>
                                    
                                    <input type="radio" id="exportJson" name="exportFormat" value="json">
                                    <label for="exportJson">JSON格式（高级）</label>
                                </div>
                            </div>
                            
                            <div class="option-group">
                                <label>导出范围：</label>
                                <div class="radio-group">
                                    <input type="radio" id="exportAll" name="exportType" value="all" checked>
                                    <label for="exportAll">全部数据</label>
                                    
                                    <input type="radio" id="exportSelected" name="exportType" value="selected">
                                    <label for="exportSelected">指定栏目</label>
                                </div>
                            </div>
                            
                            <div class="category-selection" id="exportCategorySelection" style="display: none;">
                                <label>选择栏目：</label>
                                <div class="checkbox-group" id="exportCategoryList">
                                    <!-- 栏目选择将由JavaScript生成 -->
                                </div>
                            </div>
                            
                            <button onclick="exportTemplates()" class="action-btn export-btn">
                                📁 导出数据
                            </button>
                        </div>
                    </div>
                    
                    <!-- 导入功能 -->
                    <div class="import-section">
                        <h4>📥 导入数据</h4>
                        <div class="import-options">
                            <div class="file-input-group">
                                <label for="importFile">选择文件：</label>
                                <input type="file" id="importFile" accept=".txt,.json" class="file-input">
                                <small style="color: #6c757d; margin-top: 5px; display: block;">支持 TXT 和 JSON 格式文件</small>
                            </div>
                            
                            <div class="option-group">
                                <label>导入模式：</label>
                                <div class="radio-group">
                                    <input type="radio" id="importMerge" name="importMode" value="merge" checked>
                                    <label for="importMerge">合并模式（保留现有数据）</label>
                                    
                                    <input type="radio" id="importReplace" name="importMode" value="replace">
                                    <label for="importReplace">替换模式（覆盖现有数据）</label>
                                </div>
                            </div>
                            
                            <div class="option-group">
                                <label>导入范围：</label>
                                <div class="radio-group">
                                    <input type="radio" id="importAllCategories" name="importRange" value="all" checked>
                                    <label for="importAllCategories">全部栏目</label>
                                    
                                    <input type="radio" id="importSelectedCategories" name="importRange" value="selected">
                                    <label for="importSelectedCategories">指定栏目</label>
                                </div>
                            </div>
                            
                            <div class="category-selection" id="importCategorySelection" style="display: none;">
                                <label>选择栏目：</label>
                                <div class="checkbox-group" id="importCategoryList">
                                    <!-- 栏目选择将由JavaScript生成 -->
                                </div>
                            </div>
                            
                            <button onclick="importTemplates()" class="action-btn import-btn">
                                📊 导入数据
                            </button>
                        </div>
                    </div>
                    
                    <!-- 关于程序 -->
                    <div class="import-section">
                        <h4>ℹ️ 关于程序</h4>
                        <div class="import-options">
                            <button onclick="showAboutModal()" class="action-btn export-btn">
                                📋 程序信息
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- 关于程序模态框 -->
<div id="aboutModal" class="upload-modal" style="display: none;">
    <div class="upload-modal-dialog">
        <div class="upload-modal-header">
            <h3>ℹ️ 关于程序</h3>
            <button onclick="closeAboutModal()" class="close-btn">&times;</button>
        </div>
        <div class="upload-modal-body">
            <div class="about-content">
                <h4>📝 程序介绍</h4>
                <p><strong>祖宇字文共享</strong> 是一个专为局域网环境设计的文字共享工具，支持多设备间实时同步文字内容。</p>
                
                <h4>✨ 主要功能</h4>
                <ul>
                    <li>📱 实时文字共享：支持多设备间实时同步文字内容</li>
                    <li>💬 模板管理：预设常用回复模板，快速复制使用</li>
                    <li>📤 文件传输：支持局域网内文件快速传输</li>
                    <li>🔗 二维码分享：自动生成访问二维码，扫码即用</li>
                    <li>💾 数据导入导出：支持模板数据的备份与恢复</li>
                    <li>💻 响应式设计：支持电脑端和手机端访问</li>
                    <li>🔄 实时同步：基于WebSocket技术实现实时通信</li>
                </ul>
                
                <h4>📦 技术特点</h4>
                <ul>
                    <li>轻量级设计，资源占用小</li>
                    <li>支持跨平台运行（Windows/Linux/ARM等）</li>
                    <li>无需安装客户端，浏览器直接访问</li>
                    <li>支持局域网内设备自动发现</li>
                </ul>
                
                <h4>🔗 获取源码</h4>
                <p>GitHub下载地址：<a href="https://github.com/lifuaini2019/lan-share" target="_blank">https://github.com/lifuaini2019/lan-share</a></p>
            </div>
        </div>
        <div class="upload-modal-footer">
            <button onclick="closeAboutModal()" class="cancel-btn">关闭</button>
        </div>
    </div>
</div>

<!-- 文件实时传输模态框 -->
<div id="uploadModal" class="upload-modal" style="display: none;">
    <div class="upload-modal-dialog">
        <div class="upload-modal-header">
            <h3>📤 实时文件传输</h3>
            <button onclick="closeUploadModal()" class="close-btn">&times;</button>
        </div>
        <div class="upload-modal-body">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">📤</div>
                <p>拖拽文件到此区域，或点击选择文件</p>
                <p style="color: #28a745; font-weight: 500;">局域网所有设备都能同时收到！</p>
                <input type="file" id="fileInput" multiple style="display: none;">
                <button onclick="document.getElementById('fileInput').click()" class="select-file-btn">选择文件</button>
            </div>
            
            <!-- 传输模式选择 -->
            <div class="transfer-mode-section">
                <h4>🔄 接收模式：</h4>
                <div class="mode-options">
                    <label class="mode-option">
                        <input type="radio" name="transferMode" value="exclusive" checked>
                        <span class="mode-title">🎯 独占模式</span>
                        <span class="mode-desc">一个人接收后，其他人自动取消</span>
                    </label>
                    <label class="mode-option">
                        <input type="radio" name="transferMode" value="shared">
                        <span class="mode-title">🤝 共享模式</span>
                        <span class="mode-desc">所有人都能同时接收文件</span>
                    </label>
                </div>
            </div>
            
            <div class="upload-info">
                <p><strong>支持的文件类型：</strong></p>
                <p>文档：.txt .pdf .doc .docx .xls .xlsx .ppt .pptx</p>
                <p>图片：.png .jpg .jpeg .gif</p>
                <p>压缩文件：.zip .rar</p>
                <p><strong>最大文件大小：</strong>16MB</p>
            </div>
            <div id="selectedFiles" class="selected-files" style="display: none;">
                <h4>已选择的文件：</h4>
                <ul id="fileList"></ul>
            </div>
        </div>
        <div class="upload-modal-footer">
            <button onclick="closeUploadModal()" class="cancel-btn">取消</button>
            <button onclick="sendFiles()" class="upload-submit-btn" id="uploadSubmitBtn" disabled>🚀 发送文件</button>
        </div>
    </div>
</div>

<script>
// 加载二维码功能
function loadQRCodes() {
    console.log('🔄 开始加载二维码...');
    
    fetch('/qr-code')
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            return response.json();
        })
        .then(data => {
            console.log('✅ 二维码数据获取成功:', data);
            
            // 设置主二维码
            const mainQrImage = document.getElementById('mainQrImage');
            if (mainQrImage && data.qr_data_url) {
                mainQrImage.src = data.qr_data_url;
                console.log('✅ 主二维码已设置');
            }
            
            // 设置侧边栏二维码
            const sidebarQrImage = document.getElementById('sidebarQrImage');
            if (sidebarQrImage && data.qr_data_url) {
                sidebarQrImage.src = data.qr_data_url;
                console.log('✅ 侧边栏二维码已设置');
            }
            
            // 更新网络类型显示
            const networkTypeElement = document.getElementById('network-type');
            if (networkTypeElement && data.network_type) {
                networkTypeElement.textContent = `🌐 ${data.network_type}`;
                console.log('✅ 网络类型已更新:', data.network_type);
            }
        })
        .catch(error => {
            console.error('❌ 加载二维码失败:', error);
            
            // 显示错误信息
            const mainQrImage = document.getElementById('mainQrImage');
            if (mainQrImage) {
                mainQrImage.parentNode.innerHTML = '<p class="error">二维码加载失败</p>';
            }
            
            const sidebarQrImage = document.getElementById('sidebarQrImage');
            if (sidebarQrImage) {
                sidebarQrImage.parentNode.innerHTML = '<p class="error">二维码加载失败</p>';
            }
        });
}

// 页面加载完成后执行
document.addEventListener('DOMContentLoaded', function() {
    console.log('🚀 页面加载完成，开始初始化...');
    loadQRCodes();
    initializeSocket();
    loadTemplatesData();
    
    // 延迟执行智能局域网检测，确保页面元素加载完成
    setTimeout(function() {
        performLANDetection();
    }, 1000);
});

// 显示关于程序模态框
function showAboutModal() {
    const modal = document.getElementById('aboutModal');
    if (modal) {
        modal.style.display = 'block';
    }
}

// 关闭关于程序模态框
function closeAboutModal() {
    const modal = document.getElementById('aboutModal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// 添加强制显示提示框的函数（用于测试）
function forceShowLANSwitchPrompt() {
    console.log('🔧 强制显示局域网切换提示...');
    
    // 模拟API返回数据
    const mockData = {
        success: true,
        current_host: window.location.host,
        client_ip: '192.168.3.100',
        local_ip: '192.168.3.147',
        is_ip_access: false,
        is_client_in_lan: true,
        need_switch_prompt: true,
        lan_url: 'http://192.168.3.147:9405',
        user_agent: navigator.userAgent,
        referrer: '',
        force_prompt: true
    };
    
    // 尝试调用显示函数
    if (typeof showLANSwitchPrompt === 'function') {
        showLANSwitchPrompt(mockData);
        console.log('✅ 成功调用showLANSwitchPrompt函数');
    } else if (typeof createLANSwitchModal === 'function') {
        createLANSwitchModal(mockData);
        console.log('✅ 成功调用createLANSwitchModal函数');
    } else {
        console.error('❌ 未找到显示提示的相关函数');
    }
}

// WebSocket 实时同步功能（带错误处理和自动重连）
let socket = null;
let isConnected = false;
let retryCount = 0;
let maxRetries = 10; // 最大重试次数
let retryInterval = 3000; // 重试间隔（毫秒）
let reconnectTimer = null;

// 初始化WebSocket连接
function initializeSocket() {
    console.log('🔌 开始初始化WebSocket...');
    
    try {
        updateConnectionStatus('🔄 连接中...', 'connecting');
        // 使用Go的WebSocket端点
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}/ws`;
        socket = new WebSocket(wsUrl);
        setupSocketEvents();
    } catch (error) {
        console.error('WebSocket初始化失败:', error);
        updateConnectionStatus('📡 普通模式', 'normal');
    }
}

// 设置Socket事件
function setupSocketEvents() {
    if (!socket) {
        console.log('❌ Socket对象不存在');
        return;
    }
    
    console.log('🔧 设置Socket事件监听器...');
    
    socket.onopen = function() {
        isConnected = true;
        retryCount = 0; // 重置重试计数
        if (reconnectTimer) {
            clearTimeout(reconnectTimer);
            reconnectTimer = null;
        }
        updateConnectionStatus('✅ 实时同步', 'connected');
        console.log('✅ WebSocket 连接成功');
    };
    
    socket.onerror = function(error) {
        console.error('❌ WebSocket 连接错误:', error);
        updateConnectionStatus('❌ 连接失败', 'error');
    };
    
    socket.onclose = function(event) {
        isConnected = false;
        console.log('❌ WebSocket 连接断开:', event.reason);
        updateConnectionStatus('🔄 重连中...', 'reconnecting');
        
        // 自动重连
        if (retryCount < maxRetries) {
            retryCount++;
            console.log(`🔄 尝试重连 (${retryCount}/${maxRetries})...`);
            
            reconnectTimer = setTimeout(() => {
                console.log('🔌 开始重连WebSocket...');
                initializeSocket();
            }, retryInterval);
        } else {
            console.log('❌ 达到最大重试次数，停止重连');
            updateConnectionStatus('📡 普通模式', 'normal');
        }
    };
    
    socket.onmessage = function(event) {
        try {
            const data = JSON.parse(event.data);
            console.log('🔔 收到消息:', data);
            
            switch(data.type) {
                case 'connected':
                    console.log('✅ WebSocket 连接确认');
                    break;
                case 'new_message':
                    if (data.data.action === 'add') {
                        addMessageToUI(data.data.time, data.data.content);
                        showNotification('🔔 收到新消息');
                    }
                    break;
                case 'message_deleted':
                    if (data.data.action === 'delete') {
                        removeMessageFromUI(data.data.time);
                        showNotification('🗑️ 消息已删除');
                    }
                    break;
                case 'file_incoming':
                    console.log('📁 收到文件:', data.data);
                    showIncomingFileNotification(data.data);
                    break;
                case 'file_received_notification':
                    console.log('📋 文件已被接收:', data.data);
                    handleFileReceivedNotification(data.data);
                    break;
                case 'sync_data':
                    // 处理同步数据
                    if (data.data && data.data.messages) {
                        // 清空现有消息
                        const messagesContainer = document.getElementById('messages');
                        messagesContainer.innerHTML = '';
                        
                        // 按时间倒序排列（最新的在最前面）
                        const sortedMessages = data.data.messages.slice().reverse();
                        
                        // 添加所有消息到UI
                        sortedMessages.forEach(msg => {
                            addMessageToUI(msg.time, msg.content);
                        });
                    }
                    break;
            }
        } catch (error) {
            console.error('解析WebSocket消息失败:', error);
        }
    };
    
    console.log('🚀 Socket事件监听器设置完成');
}

// 更新连接状态显示
function updateConnectionStatus(text, status) {
    const statusElement = document.getElementById('connection-status');
    const reconnectBtn = document.getElementById('reconnect-btn');
    
    if (statusElement) {
        statusElement.textContent = text;
        statusElement.className = `connection-status ${status}`;
    }
    
    // 根据状态显示/隐藏重连按钮
    if (reconnectBtn) {
        if (status === 'normal' || status === 'disconnected') {
            reconnectBtn.style.display = 'inline-block';
        } else {
            reconnectBtn.style.display = 'none';
        }
    }
}

// 手动重连功能
function manualReconnect() {
    console.log('🔄 用户手动触发重连...');
    retryCount = 0; // 重置重试计数
    
    // 清除现有的重连定时器
    if (reconnectTimer) {
        clearTimeout(reconnectTimer);
        reconnectTimer = null;
    }
    
    // 关闭现有连接
    if (socket && socket.readyState !== WebSocket.CLOSED) {
        socket.close();
    }
    
    // 立即尝试重连
    updateConnectionStatus('🔄 连接中...', 'connecting');
    setTimeout(() => {
        initializeSocket();
    }, 500);
}

// 显示通知
function showNotification(message, type = 'success') {
    const notification = document.createElement('div');
    
    // 根据类型设置不同的样式
    let backgroundColor, iconColor;
    switch(type) {
        case 'warning':
            backgroundColor = '#ff9800';
            iconColor = '#fff';
            break;
        case 'error':
            backgroundColor = '#f44336';
            iconColor = '#fff';
            break;
        case 'info':
            backgroundColor = '#2196f3';
            iconColor = '#fff';
            break;
        default: // success
            backgroundColor = '#4caf50';
            iconColor = '#fff';
    }
    
    notification.className = `notification notification-${type}`;
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${backgroundColor};
        color: ${iconColor};
        padding: 15px 20px;
        border-radius: 8px;
        z-index: 10000;
        font-weight: 500;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        max-width: 400px;
        word-wrap: break-word;
    `;
    notification.textContent = message;
    document.body.appendChild(notification);
    
    setTimeout(() => {
        if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
        }
    }, type === 'warning' ? 4000 : 3000); // 警告消息显示稍长一些
}

// 添加消息到UI
function addMessageToUI(time, content) {
    const existingMessage = document.querySelector(`[data-time="${time}"]`);
    if (existingMessage) return;
    
    const msgDiv = document.createElement('div');
    msgDiv.className = 'message';
    msgDiv.dataset.time = time;
    msgDiv.innerHTML = `
        <div class="message-header">
            <div class="message-footer">
                <span class="time">⏰ ${time}</span>
                <div class="message-actions">
                    <button onclick="deleteMessage(this)" class="delete-btn">🗑️ 删除</button>
                    <button onclick="addMessageToTemplate(this)" class="add-to-template-btn">➕ 添加到栏目</button>
                    <button onclick="copyMessage(this)" class="copy-btn large-copy-btn">📋 复制</button>
                </div>
            </div>
            <div class="content">${content}</div>
        </div>
    `;
    
    // 将新消息插入到消息列表的开头而不是末尾
    const messagesContainer = document.getElementById('messages');
    if (messagesContainer.firstChild) {
        messagesContainer.insertBefore(msgDiv, messagesContainer.firstChild);
    } else {
        messagesContainer.appendChild(msgDiv);
    }
    
    msgDiv.scrollIntoView({ behavior: 'smooth' });
}

// 从 UI 中移除消息
function removeMessageFromUI(time) {
    const messageElement = document.querySelector(`[data-time="${time}"]`);
    if (messageElement) {
        messageElement.style.animation = 'fadeOut 0.3s ease-out';
        setTimeout(() => {
            if (messageElement.parentNode) {
                messageElement.parentNode.removeChild(messageElement);
            }
        }, 300);
    }
}

// 处理回车键事件
function handleKeyPress(event) {
    if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        addMessage();
    }
}

function addMessage() {
    const content = document.getElementById('content').value.trim();
    if(!content) {
        alert("📝 请输入文字内容");
        return;
    }
    
    fetch('/add', {
        method:'POST',
        headers: {'Content-Type':'application/x-www-form-urlencoded'},
        body: 'content=' + encodeURIComponent(content)
    }).then(r=>{
        if (!r.ok) {
            throw new Error(`HTTP ${r.status}: ${r.statusText}`);
        }
        return r.json();
    }).then(res=>{
        if(res.success){
            document.getElementById('content').value='';
            document.getElementById('content').focus();
            
            // 如果没有WebSocket连接，手动添加到UI
            if (!isConnected) {
                addMessageToUI(res.time, res.content);
            }
        } else {
            alert('提交失败，请重试');
        }
    }).catch(err => {
        console.error('提交错误:', err);
        alert(`网络错误: ${err.message}`);
    });
}

function deleteMessage(btn){
    const div = btn.closest('.message');
    const time = div.dataset.time;
    
    if(!confirm('确定要删除这条内容吗？')) return;
    
    fetch('/delete', {
        method:'POST',
        headers: {'Content-Type':'application/x-www-form-urlencoded'},
        body: 'time=' + encodeURIComponent(time)
    }).then(r=>{
        if (!r.ok) {
            throw new Error(`HTTP ${r.status}: ${r.statusText}`);
        }
        return r.json();
    }).then(res=>{
        if(res.success) {
            // 如果没有WebSocket连接，手动从 UI 移除
            if (!isConnected) {
                div.remove();
            }
        } else {
            alert('删除失败，请重试');
        }
    }).catch(err => {
        console.error('删除错误:', err);
        alert(`网络错误: ${err.message}`);
    });
}

function copyMessage(btn){
    const content = btn.closest('.message').querySelector('.content').innerText;
    console.log('📋 尝试复制消息内容:', content);
    
    // 优先使用现代 Clipboard API
    if (navigator.clipboard && navigator.clipboard.writeText) {
        console.log('使用 Clipboard API 复制消息...');
        navigator.clipboard.writeText(content).then(() => {
            console.log('✅ Clipboard API 复制成功');
            showMessageCopySuccess(btn);
        }).catch((error) => {
            console.error('❌ Clipboard API 失败:', error);
            fallbackCopyMessage(content, btn);
        });
    } else {
        console.log('⚠️ Clipboard API 不可用，使用 fallback');
        fallbackCopyMessage(content, btn);
    }
}

// 消息复制的 fallback 方法
function fallbackCopyMessage(text, btn) {
    try {
        console.log('使用 execCommand 复制消息...');
        
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        textarea.style.left = '-9999px';
        textarea.style.top = '-9999px';
        document.body.appendChild(textarea);
        
        textarea.focus();
        textarea.select();
        textarea.setSelectionRange(0, 99999);
        
        const successful = document.execCommand('copy');
        document.body.removeChild(textarea);
        
        if (successful) {
            console.log('✅ execCommand 复制成功');
            showMessageCopySuccess(btn);
        } else {
            throw new Error('execCommand 返回 false');
        }
    } catch (error) {
        console.error('❌ execCommand 也失败:', error);
        showManualCopyModal(text);
    }
}

// 显示消息复制成功的反馈
function showMessageCopySuccess(btn) {
    const originalText = btn.innerHTML;
    const originalBackground = btn.style.background;
    
    btn.innerHTML = '✅ 已复制';
    btn.style.background = '#28a745';
    
    setTimeout(() => {
        btn.innerHTML = originalText;
        btn.style.background = originalBackground;
    }, 1500);
    
    showNotification('📋 消息内容已复制到剪贴板');
}

// 显示通知
function showNotification(message, type = 'success') {
    // 检查是否已经有相同的通知
    const existingNotifications = document.querySelectorAll('.notification');
    for (let i = 0; i < existingNotifications.length; i++) {
        if (existingNotifications[i].textContent.includes(message)) {
            // 更新现有通知的时间
            existingNotifications[i].dataset.timestamp = Date.now();
            return;
        }
    }
    
    const notification = document.createElement('div');
    
    // 根据类型设置不同的样式
    let backgroundColor, iconColor;
    switch(type) {
        case 'warning':
            backgroundColor = '#ff9800';
            iconColor = '#fff';
            break;
        case 'error':
            backgroundColor = '#f44336';
            iconColor = '#fff';
            break;
        case 'info':
            backgroundColor = '#2196f3';
            iconColor = '#fff';
            break;
        default: // success
            backgroundColor = '#4caf50';
            iconColor = '#fff';
    }
    
    notification.className = `notification notification-${type}`;
    notification.dataset.timestamp = Date.now();
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${backgroundColor};
        color: ${iconColor};
        padding: 15px 20px;
        border-radius: 8px;
        z-index: 10000;
        font-weight: 500;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        max-width: 400px;
        word-wrap: break-word;
        animation: slideInRight 0.3s ease-out;
    `;
    notification.textContent = message;
    document.body.appendChild(notification);
    
    // 5秒后自动移除通知
    setTimeout(() => {
        if (notification.parentNode) {
            notification.style.animation = 'fadeOut 0.3s ease-out';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }
    }, type === 'warning' ? 4000 : 3000); // 警告消息显示稍长一些
}

// 添加动画样式
function addNotificationStyles() {
    // 检查是否已经添加过样式
    if (document.getElementById('notification-styles')) {
        return;
    }
    
    const style = document.createElement('style');
    style.id = 'notification-styles';
    style.textContent = `
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes fadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
            }
        }
    `;
    document.head.appendChild(style);
}

// 添加消息到模板栏目
function addMessageToTemplate(btn) {
    const content = btn.closest('.message').querySelector('.content').innerText;
    const time = btn.closest('.message').dataset.time;
    
    console.log('🔄 添加消息到模板:', content);
    console.log('🔍 检查 templatesData:', templatesData);
    
    // 检查模板数据是否存在
    if (!templatesData || !templatesData.categories) {
        alert('模板数据未加载，请刷新页面重试');
        return;
    }
    
    // 创建栏目选择模态框
    showCategorySelectionModal(content, time, btn);
}

// 显示栏目选择模态框
function showCategorySelectionModal(content, time, sourceBtn) {
    // 创建模态框
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.6);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
    `;
    
    const dialog = document.createElement('div');
    dialog.style.cssText = `
        background: white;
        padding: 25px;
        border-radius: 12px;
        max-width: 500px;
        width: 90%;
        max-height: 80vh;
        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        overflow-y: auto;
    `;
    
    // 生成栏目选项
    let categoryOptions = '';
    for (const [key, category] of Object.entries(templatesData.categories)) {
        if (key !== 'settings') { // 排除系统设置
            categoryOptions += `<option value="${key}">${category.icon} ${category.name}</option>`;
        }
    }
    
    dialog.innerHTML = `
        <h3 style="margin: 0 0 20px 0; color: #333; display: flex; align-items: center;">
            ➕ 添加到栏目
        </h3>
        
        <div style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #555;">选择栏目：</label>
            <select id="modalCategorySelect" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px;">
                <option value="">请选择栏目...</option>
                ${categoryOptions}
            </select>
        </div>
        
        <div style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #555;">模板标题：</label>
            <input type="text" id="modalTemplateTitle" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px;" placeholder="请输入模板标题..." value="共享内容 ${time}">
        </div>
        
        <div style="margin-bottom: 20px;">
            <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #555;">模板内容：</label>
            <textarea id="modalTemplateContent" style="width: 100%; height: 120px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; resize: vertical;" readonly>${content}</textarea>
        </div>
        
        <div style="display: flex; gap: 10px; justify-content: flex-end;">
            <button onclick="this.closest('.category-modal').remove()" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px;">
                取消
            </button>
            <button onclick="confirmAddToTemplate('${content.replace(/'/g, "\\'").replace(/"/g, '\\"')}', '${time}')" style="padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px;">
                ✅ 确认添加
            </button>
        </div>
    `;
    
    modal.className = 'category-modal';
    modal.appendChild(dialog);
    document.body.appendChild(modal);
    
    // 点击背景关闭
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            modal.remove();
        }
    });
    
    // 聚焦到栏目选择
    setTimeout(() => {
        document.getElementById('modalCategorySelect').focus();
    }, 100);
}

// 确认添加到模板
function confirmAddToTemplate(content, time) {
    const categoryKey = document.getElementById('modalCategorySelect').value;
    let title = document.getElementById('modalTemplateTitle').value.trim();
    const templateContent = document.getElementById('modalTemplateContent').value.trim();
    
    if (!categoryKey) {
        alert('请选择栏目');
        return;
    }
    
    // 如果标题为空，自动填入默认值
    if (!title) {
        title = '未说明';
        // 同时更新界面显示
        document.getElementById('modalTemplateTitle').value = title;
    }
    
    if (!templateContent) {
        alert('模板内容不能为空');
        return;
    }
    
    // 显示加载状态
    const confirmBtn = document.querySelector('.category-modal button[onclick*="confirmAddToTemplate"]');
    const originalText = confirmBtn.innerHTML;
    confirmBtn.innerHTML = '🔄 添加中...';
    confirmBtn.disabled = true;
    
    // 发送请求
    fetch(`/api/templates/category/${categoryKey}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            title: title,
            content: templateContent
        })
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(err => Promise.reject(err));
        }
        return response.json();
    })
    .then(result => {
        if (result.success) {
            // 关闭模态框
            document.querySelector('.category-modal').remove();
            
            // 显示成功提示
            if (result.is_duplicate) {
                showNotification('⚠️ ' + result.message);
            } else {
                showNotification('✅ 已成功添加到栏目！');
            }
            
            // 重新加载模板数据
            setTimeout(() => {
                loadTemplatesData();
            }, 500);
        } else {
            alert('添加失败：' + result.error);
        }
    })
    .catch(error => {
        console.error('添加模板错误:', error);
        alert('添加失败：' + (error.error || error.message || '未知错误'));
    })
    .finally(() => {
        // 恢复按钮状态
        confirmBtn.innerHTML = originalText;
        confirmBtn.disabled = false;
    });
}

function toggleQR() {
    const qrContent = document.getElementById('qr-content');
    const toggleBtn = document.getElementById('toggle-btn');
    
    if (qrContent.style.display === 'none') {
        qrContent.style.display = 'block';
        toggleBtn.innerHTML = '🙈 隐藏二维码';
    } else {
        qrContent.style.display = 'none';
        toggleBtn.innerHTML = '👀 显示二维码';
    }
}

// === 智能局域网检测功能 ===

// 🔧 新的客户端ping检测方案
function performLANDetection(retryCount = 0) {
    console.log('🔍 开始智能局域网检测 v2.0...尝试次数:', retryCount);
    console.log('🌐 当前访问地址:', window.location.href);
    console.log('🏠 当前主机:', window.location.host);
    
    // 检查是否为IP访问
    const hostname = window.location.hostname;
    const isIPAccess = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(hostname);
    
    console.log('📊 访问方式分析:');
    console.log('  - 主机名:', hostname);
    console.log('  - 是否IP访问:', isIPAccess);
    
    // 如果是IP访问，不需要检测
    if (isIPAccess) {
        console.log('✅ IP访问，无需显示切换提示');
        return;
    }
    
    console.log('🔍 域名访问，开始客户端ping检测...');
    
    // 获取服务器的局域网IP配置
    const serverLANIP = '192.168.3.147'; // 玩客云IP
    const serverPort = '9405';
    const lanURL = `http://${serverLANIP}:${serverPort}`;
    
    console.log('🎯 目标局域网地址:', lanURL);
    
    // 客户端ping检测：尝试访问局域网IP
    pingLANServer(serverLANIP, serverPort)
        .then(isReachable => {
            console.log('📡 Ping检测结果:', isReachable);
            
            if (isReachable) {
                console.log('✅ 局域网服务器可达，显示切换提示');
                
                // 构造检测数据
                const detectionData = {
                    success: true,
                    current_host: window.location.host,
                    client_ip: 'client-detected', // 客户端检测
                    local_ip: serverLANIP,
                    is_ip_access: false,
                    is_client_in_lan: true,
                    need_switch_prompt: true,
                    lan_url: lanURL,
                    detection_method: 'client-ping'
                };
                
                // 显示切换提示
                if (typeof showLANSwitchPrompt === 'function') {
                    showLANSwitchPrompt(detectionData);
                    console.log('✅ 已调用showLANSwitchPrompt函数');
                } else {
                    console.error('❌ 未找到showLANSwitchPrompt函数');
                }
            } else {
                console.log('❌ 局域网服务器不可达，不显示切换提示');
                console.log('💡 可能原因:');
                console.log('  - 不在同一局域网');
                console.log('  - 网络防火墙阻止');
                console.log('  - 服务器未启动');
                
                // 如果是第一次检测失败，稍后重试
                if (retryCount === 0) {
                    console.log('⏰ 3秒后重试检测...');
                    setTimeout(() => performLANDetection(1), 3000);
                }
            }
        })
        .catch(error => {
            console.error('❌ Ping检测出错:', error);
            
            // 如果是第一次检测出错，稍后重试
            if (retryCount === 0) {
                console.log('⏰ 3秒后重试检测...');
                setTimeout(() => performLANDetection(1), 3000);
            }
        });
}

// 客户端ping检测函数 - 多种方法组合
// 🧠 智能局域网检测 - 多重检测方案
async function pingLANServer(ip, port, timeout = 3000) {
    console.log(`🧠 开始智能网络特征检测: ${ip}:${port}`);
    
    try {
        // 1. 获取客户端真实IP（WebRTC方式）
        let clientIP = await getClientRealIP();
        console.log(`📍 WebRTC IP检测结果: ${clientIP}`);
        
        // 2. 如果WebRTC检测到的是公网IP，尝试服务端检测
        if (clientIP !== 'unknown' && !isPrivateIPAddress(clientIP)) {
            console.log(`🔄 检测到公网IP，尝试服务端辅助检测...`);
            const serverResult = await getServerDetectionResult();
            console.log(`📡 服务端检测结果:`, serverResult);
            
            // 🔧 关键修复：直接使用服务端的判断结果
            if (serverResult && serverResult.is_client_in_lan) {
                console.log(`✅ 服务端判断客户端在局域网内`);
                console.log(`📡 服务端检测IP: ${serverResult.client_ip}`);
                return true; // 直接返回true，显示切换提示
            }
        }
        
        // 3. 分析网络环境
        const networkAnalysis = analyzeNetworkEnvironment();
        console.log(`🌐 网络环境分析:`, networkAnalysis);
        
        // 4. 综合判断是否在局域网
        const result = determineIfInLAN(clientIP, ip, networkAnalysis);
        console.log(`🎯 智能检测最终结果: ${result.isInLAN} (置信度: ${result.confidence}%)`);
        
        return result.isInLAN;
        
    } catch (error) {
        console.log(`❌ 智能检测异常: ${error.message}`);
        // 异常情况下，尝试服务端检测
        try {
            console.log(`🔄 异常恢复: 尝试服务端检测...`);
            const fallbackIP = await getServerDetectedIP();
            if (fallbackIP !== 'unknown' && isPrivateIPAddress(fallbackIP)) {
                console.log(`✅ 异常恢复成功: 检测到局域网IP ${fallbackIP}`);
                return true;
            }
        } catch (e) {
            console.log(`❌ 异常恢复也失败: ${e.message}`);
        }
        return false;
    }
}

// 通过服务端API获取客户端IP
async function getServerDetectedIP() {
    try {
        console.log(`📡 开始服务端IP检测...`);
        
        // 使用当前域名的API，避免跨域问题
        const response = await fetch('/api/lan-check', {
            method: 'GET',
            cache: 'no-cache',
            signal: AbortSignal.timeout(5000)
        });
        
        if (response.ok) {
            const data = await response.json();
            console.log(`📡 服务端检测响应:`, data);
            
            if (data.client_ip && data.client_ip !== 'unknown') {
                console.log(`✅ 服务端检测到客户端IP: ${data.client_ip}`);
                return data.client_ip;
            }
        }
        
        console.log(`⚠️ 服务端检测未返回有效IP`);
        return 'unknown';
        
    } catch (error) {
        console.log(`❌ 服务端IP检测失败: ${error.message}`);
        return 'unknown';
    }
}

// 🔧 新增：获取服务端完整检测结果
async function getServerDetectionResult() {
    try {
        console.log(`📡 开始服务端完整检测...`);
        
        // 使用当前域名的API，避免跨域问题
        const response = await fetch('/api/lan-check', {
            method: 'GET',
            cache: 'no-cache',
            signal: AbortSignal.timeout(5000)
        });
        
        if (response.ok) {
            const data = await response.json();
            console.log(`📡 服务端检测响应:`, data);
            return data;
        }
        
        console.log(`⚠️ 服务端检测请求失败`);
        return null;
        
    } catch (error) {
        console.log(`❌ 服务端检测失败: ${error.message}`);
        return null;
    }
}

// 获取客户端所有IP地址（通过WebRTC STUN）
function getClientRealIP() {
    return new Promise((resolve) => {
        console.log(`🔍 开始WebRTC多IP检测...`);
        
        const pc = new RTCPeerConnection({
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun.cloudflare.com:3478' }
            ]
        });
        
        const detectedIPs = [];
        let candidateCount = 0;
        let gatheringComplete = false;
        
        pc.createDataChannel('test');
        
        pc.onicecandidate = (event) => {
            if (event.candidate) {
                candidateCount++;
                const candidate = event.candidate.candidate;
                console.log(`🔍 ICE候选 #${candidateCount}: ${candidate}`);
                
                // 提取IP地址 - 更精确的正则表达式
                const ipMatch = candidate.match(/(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/);
                if (ipMatch) {
                    const detectedIP = ipMatch[1];
                    // 跳过回环地址和链路本地地址
                    if (detectedIP !== '127.0.0.1' && 
                        !detectedIP.startsWith('169.254.') &&
                        detectedIP !== '0.0.0.0' &&
                        !detectedIPs.includes(detectedIP)) {
                        detectedIPs.push(detectedIP);
                        console.log(`✅ 发现有效IP: ${detectedIP}`);
                    }
                }
            }
        };
        
        pc.onicegatheringstatechange = () => {
            console.log(`🔄 ICE收集状态: ${pc.iceGatheringState}`);
            if (pc.iceGatheringState === 'complete') {
                gatheringComplete = true;
                console.log(`✅ ICE收集完成，共发现 ${detectedIPs.length} 个IP`);
                pc.close();
                
                // 选择最佳IP
                const bestIP = selectBestIP(detectedIPs);
                console.log(`🎯 选择最佳IP: ${bestIP}`);
                resolve(bestIP);
            }
        };
        
        pc.createOffer()
            .then(offer => {
                console.log(`📝 创建SDP offer成功`);
                return pc.setLocalDescription(offer);
            })
            .then(() => {
                console.log(`✅ 设置本地描述成功，等待ICE候选...`);
            })
            .catch(error => {
                console.log(`❌ WebRTC设置失败: ${error.message}`);
                resolve('unknown');
            });
        
        // 10秒超时（给WebRTC更多时间收集所有IP）
        setTimeout(() => {
            if (!gatheringComplete) {
                console.log(`⏰ WebRTC IP检测超时 (10秒)`);
                pc.close();
                
                if (detectedIPs.length > 0) {
                    const bestIP = selectBestIP(detectedIPs);
                    console.log(`🎯 超时后选择最佳IP: ${bestIP}`);
                    resolve(bestIP);
                } else {
                    console.log(`❌ 未检测到任何有效IP`);
                    resolve('unknown');
                }
            }
        }, 10000);
    });
}

// 选择最佳IP地址
function selectBestIP(ips) {
    console.log(`🔍 开始选择最佳IP，候选列表:`, ips);
    
    if (ips.length === 0) {
        return 'unknown';
    }
    
    if (ips.length === 1) {
        return ips[0];
    }
    
    // 优先级排序
    const priorities = [];
    
    ips.forEach(ip => {
        let priority = 0;
        let type = '';
        
        if (isPrivateIPAddress(ip)) {
            // 私有IP优先级更高
            if (ip.startsWith('192.168.')) {
                priority = 100; // 192.168.x.x 最高优先级
                type = '192.168网段';
            } else if (ip.startsWith('10.')) {
                priority = 90;  // 10.x.x.x 次高优先级
                type = '10网段';
            } else if (ip.startsWith('172.')) {
                priority = 80;  // 172.16-31.x.x 第三优先级
                type = '172网段';
            }
        } else {
            // 公网IP优先级较低
            priority = 50;
            type = '公网IP';
        }
        
        priorities.push({ ip, priority, type });
        console.log(`  - ${ip}: ${priority}分 (${type})`);
    });
    
    // 按优先级排序
    priorities.sort((a, b) => b.priority - a.priority);
    
    const selectedIP = priorities[0].ip;
    console.log(`🏆 最终选择: ${selectedIP} (${priorities[0].type})`);
    
    return selectedIP;
}

// 分析网络环境
function analyzeNetworkEnvironment() {
    const analysis = {
        connectionType: 'unknown',
        effectiveType: 'unknown',
        downlink: 0,
        rtt: 0,
        saveData: false,
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        language: navigator.language
    };
    
    // 获取网络连接信息
    if ('connection' in navigator) {
        const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
        if (conn) {
            analysis.connectionType = conn.type || 'unknown';
            analysis.effectiveType = conn.effectiveType || 'unknown';
            analysis.downlink = conn.downlink || 0;
            analysis.rtt = conn.rtt || 0;
            analysis.saveData = conn.saveData || false;
            
            console.log(`📊 网络连接详情:`);
            console.log(`  - 连接类型: ${analysis.connectionType}`);
            console.log(`  - 有效类型: ${analysis.effectiveType}`);
            console.log(`  - 下行带宽: ${analysis.downlink} Mbps`);
            console.log(`  - 往返时间: ${analysis.rtt} ms`);
        }
    }
    
    // 检测设备类型
    analysis.deviceType = getDeviceType();
    console.log(`📱 设备类型: ${analysis.deviceType}`);
    
    return analysis;
}

// 获取设备类型
function getDeviceType() {
    const ua = navigator.userAgent.toLowerCase();
    
    if (/mobile|android|iphone|ipad|phone/i.test(ua)) {
        return 'mobile';
    } else if (/tablet|ipad/i.test(ua)) {
        return 'tablet';
    } else {
        return 'desktop';
    }
}

// 综合判断是否在局域网
function determineIfInLAN(clientIP, serverIP, networkInfo) {
    console.log(`🔍 开始综合局域网判断分析...`);
    console.log(`📍 客户端IP: ${clientIP}`);
    console.log(`🖥️ 服务器IP: ${serverIP}`);
    
    let confidence = 0;
    const reasons = [];
    
    // 1. IP地址分析（权重最高：60%）
    if (clientIP !== 'unknown') {
        const ipAnalysis = analyzeIPRelationship(clientIP, serverIP);
        confidence += ipAnalysis.score;
        reasons.push(...ipAnalysis.reasons);
    } else {
        reasons.push(`⚠️ 无法获取客户端IP (-10分)`);
        confidence -= 10;
    }
    
    // 2. 网络连接类型分析（权重：25%）
    const connectionAnalysis = analyzeConnectionType(networkInfo);
    confidence += connectionAnalysis.score;
    reasons.push(...connectionAnalysis.reasons);
    
    // 3. 网络质量分析（权重：15%）
    const qualityAnalysis = analyzeNetworkQuality(networkInfo);
    confidence += qualityAnalysis.score;
    reasons.push(...qualityAnalysis.reasons);
    
    console.log(`📊 详细分析结果:`);
    reasons.forEach(reason => console.log(`  ${reason}`));
    console.log(`🎯 总置信度: ${confidence}%`);
    
    // 判断阈值：75%以上认为在局域网
    const isInLAN = confidence >= 75;
    const certainty = isInLAN ? '✅ 在局域网内' : '❌ 不在局域网';
    console.log(`📋 最终判断: ${certainty} (置信度: ${confidence}%)`);
    
    return {
        isInLAN: isInLAN,
        confidence: confidence,
        reasons: reasons
    };
}

// 分析IP关系
function analyzeIPRelationship(clientIP, serverIP) {
    const analysis = { score: 0, reasons: [] };
    
    if (!isValidIP(clientIP) || !isValidIP(serverIP)) {
        analysis.reasons.push(`❌ IP格式无效`);
        return analysis;
    }
    
    const clientParts = clientIP.split('.').map(Number);
    const serverParts = serverIP.split('.').map(Number);
    
    // 检查是否同一C类网段 (最高分)
    if (clientParts[0] === serverParts[0] && 
        clientParts[1] === serverParts[1] && 
        clientParts[2] === serverParts[2]) {
        analysis.score += 60;
        analysis.reasons.push(`✅ 同一C类网段: ${clientIP} ↔ ${serverIP} (+60分)`);
    }
    // 检查是否同一B类网段
    else if (clientParts[0] === serverParts[0] && 
             clientParts[1] === serverParts[1]) {
        analysis.score += 40;
        analysis.reasons.push(`🔶 同一B类网段: ${clientIP} ↔ ${serverIP} (+40分)`);
    }
    // 检查是否同一A类网段
    else if (clientParts[0] === serverParts[0]) {
        analysis.score += 20;
        analysis.reasons.push(`🔶 同一A类网段: ${clientIP} ↔ ${serverIP} (+20分)`);
    }
    // 检查是否都是私有IP
    else if (isPrivateIPAddress(clientIP) && isPrivateIPAddress(serverIP)) {
        analysis.score += 10;
        analysis.reasons.push(`🔶 都是私有IP: ${clientIP} ↔ ${serverIP} (+10分)`);
    }
    else {
        analysis.reasons.push(`❌ IP网段不匹配: ${clientIP} ↔ ${serverIP} (0分)`);
    }
    
    return analysis;
}

// 分析连接类型
function analyzeConnectionType(networkInfo) {
    const analysis = { score: 0, reasons: [] };
    
    if (networkInfo.connectionType !== 'unknown') {
        switch (networkInfo.connectionType) {
            case 'wifi':
                analysis.score += 25;
                analysis.reasons.push(`✅ WiFi连接 (+25分)`);
                break;
            case 'ethernet':
                analysis.score += 25;
                analysis.reasons.push(`✅ 以太网连接 (+25分)`);
                break;
            case 'cellular':
                analysis.score -= 15;
                analysis.reasons.push(`❌ 移动网络连接 (-15分)`);
                break;
            default:
                analysis.reasons.push(`🔶 未知连接类型: ${networkInfo.connectionType} (0分)`);
        }
    } else {
        analysis.reasons.push(`⚠️ 无法检测连接类型 (0分)`);
    }
    
    return analysis;
}

// 分析网络质量
function analyzeNetworkQuality(networkInfo) {
    const analysis = { score: 0, reasons: [] };
    
    // RTT分析
    if (networkInfo.rtt > 0) {
        if (networkInfo.rtt < 10) {
            analysis.score += 15;
            analysis.reasons.push(`✅ 极低延迟: ${networkInfo.rtt}ms (+15分)`);
        } else if (networkInfo.rtt < 30) {
            analysis.score += 10;
            analysis.reasons.push(`✅ 低延迟: ${networkInfo.rtt}ms (+10分)`);
        } else if (networkInfo.rtt < 100) {
            analysis.score += 5;
            analysis.reasons.push(`🔶 中等延迟: ${networkInfo.rtt}ms (+5分)`);
        } else {
            analysis.reasons.push(`❌ 高延迟: ${networkInfo.rtt}ms (0分)`);
        }
    }
    
    // 带宽分析
    if (networkInfo.downlink > 0) {
        if (networkInfo.downlink >= 100) {
            analysis.reasons.push(`✅ 超高带宽: ${networkInfo.downlink}Mbps`);
        } else if (networkInfo.downlink >= 10) {
            analysis.reasons.push(`✅ 高带宽: ${networkInfo.downlink}Mbps`);
        } else {
            analysis.reasons.push(`🔶 中等带宽: ${networkInfo.downlink}Mbps`);
        }
    }
    
    return analysis;
}

// 验证IP格式
function isValidIP(ip) {
    if (!ip || ip === 'unknown') return false;
    const parts = ip.split('.');
    return parts.length === 4 && parts.every(part => {
        const num = parseInt(part, 10);
        return num >= 0 && num <= 255 && part === num.toString();
    });
}

// 判断是否为私有IP地址
function isPrivateIPAddress(ip) {
    if (!isValidIP(ip)) return false;
    
    const parts = ip.split('.').map(Number);
    
    // 10.0.0.0/8
    if (parts[0] === 10) return true;
    
    // 172.16.0.0/12
    if (parts[0] === 172 && parts[1] >= 16 && parts[1] <= 31) return true;
    
    // 192.168.0.0/16
    if (parts[0] === 192 && parts[1] === 168) return true;
    
    return false;
}

// 旧的备用检测函数已删除，现在使用智能网络特征检测

// 显示局域网切换提示
function showLANSwitchPrompt(detectionData) {
    console.log('📢 showLANSwitchPrompt 被调用，数据:', detectionData);
    
    // 检查是否已经在显示提示，避免重复
    const existingModal = document.getElementById('lanSwitchModal');
    if (existingModal) {
        console.log('⚠️ 局域网切换提示已存在，跳过');
        console.log('🔧 现有提示框:', existingModal);
        console.log('🔧 现有提示框样式:', existingModal.style);
        console.log('🔧 现有提示框显示状态:', getComputedStyle(existingModal).display);
        return;
    }
    
    console.log('🔔 开始创建局域网切换提示框');
    
    // 显示通知
    if (typeof showNotification === 'function') {
        showNotification('检测到局域网环境，准备显示切换提示...', 'info');
    }
    
    // 确保DOM已准备好
    console.log('📄 DOM准备状态检查:');
    console.log('  - document.readyState:', document.readyState);
    console.log('  - document.body存在:', !!document.body);
    
    if (document.readyState !== 'complete' && document.readyState !== 'interactive') {
        console.log('⏳ DOM未准备好，等待加载完成...');
        window.addEventListener('load', () => {
            console.log('✅ window.load事件触发');
            createLANSwitchModal(detectionData);
        }, {once: true});
        
        document.addEventListener('DOMContentLoaded', () => {
            console.log('✅ DOMContentLoaded事件触发');
            createLANSwitchModal(detectionData);
        }, {once: true});
    } else {
        console.log('✅ DOM已准备好，直接创建提示框');
        createLANSwitchModal(detectionData);
    }
}

// 创建局域网切换提示模态框
function createLANSwitchModal(detectionData) {
    console.log('🔨 开始创建局域网切换提示模态框');
    console.log('📊 接收到的数据:', detectionData);
    
    // 再次检查是否已存在
    const existingModal = document.getElementById('lanSwitchModal');
    if (existingModal) {
        console.log('⚠️ 局域网切换提示已存在，跳过');
        return;
    }
    
    // 确保body元素存在
    console.log('📄 body元素检查:');
    console.log('  - document.body存在:', !!document.body);
    if (document.body) {
        console.log('  - document.body.style.display:', document.body.style.display);
    }
    
    if (!document.body) {
        console.log('⏳ body元素未准备好，等待DOM加载完成...');
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                console.log('✅ DOMContentLoaded事件触发，重新创建提示框');
                createLANSwitchModal(detectionData);
            }, {once: true});
        } else {
            console.log('⏰ 延迟100ms后重试...');
            setTimeout(() => {
                createLANSwitchModal(detectionData);
            }, 100);
        }
        return;
    }
    
    // 强制确保body存在并可见
    if (!document.body || document.body.style.display === 'none') {
        console.log('🔧 确保body元素可见...');
        document.body.style.display = 'block';
    }
    
    console.log('🔧 开始创建DOM元素...');
    
    const modal = document.createElement('div');
    modal.id = 'lanSwitchModal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        backdrop-filter: blur(2px);
        animation: fadeIn 0.3s ease-out;
    `;
    
    console.log('🔧 modal元素创建完成:', modal);
    
    const dialog = document.createElement('div');
    dialog.style.cssText = `
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 16px;
        padding: 30px;
        max-width: 450px;
        width: 90%;
        color: white;
        text-align: center;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        transform: scale(0.9);
        animation: popIn 0.3s ease-out forwards;
    `;
    
    console.log('🔧 dialog元素创建完成:', dialog);
    
    // 添加动画样式
    console.log('🔧 添加动画样式...');
    const style = document.createElement('style');
    style.textContent = `
        @keyframes popIn {
            to {
                transform: scale(1);
            }
        }
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        .lan-switch-btn {
            background: linear-gradient(45deg, #28a745, #20c997);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            margin: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
        }
        .lan-switch-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(40, 167, 69, 0.4);
        }
        .lan-cancel-btn {
            background: linear-gradient(45deg, #6c757d, #5a6268);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            margin: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(108, 117, 125, 0.3);
        }
        .lan-cancel-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(108, 117, 125, 0.4);
        }
    `;
    document.head.appendChild(style);
    
    console.log('🔧 样式添加完成');
    
    // 构建对话框内容
    console.log('🔧 构建对话框内容...');
    dialog.innerHTML = `
        <div style="margin-bottom: 20px;">
            <div style="font-size: 48px; margin-bottom: 16px;">🏠</div>
            <h2 style="margin: 0 0 16px 0; font-size: 24px; font-weight: 600;">检测到您在局域网环境</h2>
            <p style="margin: 0; font-size: 16px; line-height: 1.5; opacity: 0.9;">
                您正在通过域名访问，但实际在局域网环境中。<br>
                是否切换到局域网地址以获得更快的访问速度？
            </p>
        </div>
        
        <div style="background: rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 16px; margin: 20px 0; text-align: left;">
            <div style="margin-bottom: 8px;">
                <strong>🌐 当前访问：</strong> ${detectionData.current_host}
            </div>
            <div style="margin-bottom: 8px;">
                <strong>🏠 局域网地址：</strong> ${detectionData.lan_url}
            </div>
            <div>
                <strong>📶 您的IP：</strong> ${detectionData.client_ip}
            </div>
        </div>
        
        <div style="margin-top: 25px;">
            <button class="lan-switch-btn" onclick="switchToLAN('${detectionData.lan_url}')" id="lanSwitchBtn">
                🚀 切换到局域网
            </button>
            <button class="lan-cancel-btn" onclick="closeLANSwitchModal()" id="lanCancelBtn">
                🙅 继续使用域名
            </button>
        </div>
        
        <div style="margin-top: 20px; font-size: 13px; opacity: 0.7;">
            💡 局域网访问速度更快，且数据不经过公网
        </div>
    `;
    
    console.log('🔧 对话框内容构建完成');
    
    modal.appendChild(dialog);
    console.log('🔧 将dialog添加到modal');
    
    // 确保添加到body的最前面，以确保z-index最高
    if (document.body.firstChild) {
        document.body.insertBefore(modal, document.body.firstChild);
    } else {
        document.body.appendChild(modal);
    }
    
    console.log('✅ 将modal添加到document.body');
    
    // 验证元素是否已添加到DOM
    setTimeout(() => {
        const addedModal = document.getElementById('lanSwitchModal');
        if (addedModal) {
            console.log('✅ 提示框已成功添加到DOM');
            console.log('🔧 提示框显示状态:', getComputedStyle(addedModal).display);
            console.log('🔧 提示框z-index:', addedModal.style.zIndex);
            
            // 强制显示
            addedModal.style.display = 'flex';
            addedModal.style.opacity = '1';
        } else {
            console.error('❌ 提示框未成功添加到DOM');
        }
    }, 0);
    
    // 显示通知
    if (typeof showNotification === 'function') {
        showNotification('局域网切换提示已显示', 'success');
    }
    
    // 点击背景关闭
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            console.log('🔧 点击背景关闭提示框');
            closeLANSwitchModal();
        }
    });
    
    // 添加键盘事件监听
    const keydownHandler = (e) => {
        if (e.key === 'Escape' && document.getElementById('lanSwitchModal')) {
            console.log('🔧 按ESC键关闭提示框');
            closeLANSwitchModal();
        }
    };
    document.addEventListener('keydown', keydownHandler);
    
    // 保存事件处理函数引用，以便后续移除
    modal.keydownHandler = keydownHandler;
    
    // 强制显示提示框（确保可见）
    console.log('🔧 强制显示提示框...');
    setTimeout(() => {
        if (modal) {
            modal.style.display = 'flex';
            console.log('🔧 第一次强制显示提示框完成');
        }
    }, 100);
    
    // 再次强制显示（确保在所有情况下都可见）
    setTimeout(() => {
        if (modal) {
            modal.style.display = 'flex';
            modal.style.opacity = '1';
            console.log('🔧 第二次强制显示提示框完成');
        }
    }, 500);
    
    console.log('✅ 局域网切换提示框创建完成');
}

// 切换到局域网地址
function switchToLAN(lanURL) {
    console.log('🚀 切换到局域网:', lanURL);
    showNotification('正在切换到局域网地址...', 'info');
    
    // 显示加载提示
    const modal = document.getElementById('lanSwitchModal');
    if (modal) {
        const dialog = modal.querySelector('div');
        if (dialog) {
            dialog.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <div style="font-size: 48px; margin-bottom: 16px;">🔄</div>
                    <h2 style="margin: 0 0 16px 0; font-size: 24px; font-weight: 600;">正在切换...</h2>
                    <p style="margin: 0; font-size: 16px; line-height: 1.5; opacity: 0.9;">
                        正在跳转到局域网地址，请稍候...
                    </p>
                </div>
            `;
        }
    }
    
    // 延迟跳转，让用户看到提示
    setTimeout(() => {
        window.location.href = lanURL;
    }, 1000);
}

// 关闭局域网切换提示
function closeLANSwitchModal() {
    console.log('❌ 关闭局域网切换提示');
    const modal = document.getElementById('lanSwitchModal');
    if (modal) {
        modal.remove();
        showNotification('已取消切换', 'info');
    }
}

// 页面加载完成后初始化
// === 客服模板功能 ===
let templatesData = null;
let currentInterface = 'home'; // 当前显示的界面

// 模板数据加载函数（重命名以避免混淆）
function loadTemplatesData() {
    console.log('🔧 开始加载客服模板数据...');
    fetch('/api/templates')
        .then(response => {
            console.log('📡 API响应状态:', response.status);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            return response.json();
        })
        .then(data => {
            console.log('✅ 模板数据加载成功:', data);
            templatesData = data;
            renderCategoryMenu();
            // 默认显示共享首页
            switchInterface('home');
            
            // 初始化文件上传功能
            initializeFileUpload();
            
            // 设置输入框焦点
            document.getElementById('content').focus();
        })
        .catch(error => {
            console.error('❌ 加载模板数据失败:', error);
            // 显示错误提示
            const menuContainer = document.getElementById('categoryMenu');
            if (menuContainer) {
                menuContainer.innerHTML = '<div style="padding: 20px; color: #ff6b6b; text-align: center;">⚠️ 模板加载失败<br>请刷新页面重试</div>';
            }
        });
}

// 渲染分类菜单
function renderCategoryMenu() {
    const menuContainer = document.getElementById('categoryMenu');
    let menuHTML = '';
    
    // 添加共享文字选项
    menuHTML += `
        <div class="category-item ${currentInterface === 'home' ? 'active' : ''}" onclick="switchInterface('home')" data-category="home">
            <span class="category-icon">🏠</span>
            <span class="category-name">共享文字</span>
        </div>
    `;
    
    // 添加其他分类
    for (const [key, category] of Object.entries(templatesData.categories)) {
        if (key !== 'home') { // 排除home，因为已经作为共享文字处理
            menuHTML += `
                <div class="category-item ${currentInterface === key ? 'active' : ''}" onclick="switchInterface('${key}')" data-category="${key}">
                    <span class="category-icon">${category.icon}</span>
                    <span class="category-name">${category.name}</span>
                </div>
            `;
        }
    }
    
    menuContainer.innerHTML = menuHTML;
}

// 切换界面
function switchInterface(interfaceKey) {
    // 更新当前界面
    currentInterface = interfaceKey;
    
    // 隐藏所有界面
    document.querySelectorAll('.interface-container').forEach(container => {
        container.style.display = 'none';
    });
    
    // 更新菜单选中状态
    document.querySelectorAll('.category-item').forEach(item => {
        item.classList.remove('active');
    });
    document.querySelector(`[data-category="${interfaceKey}"]`).classList.add('active');
    
    // 显示对应界面
    if (interfaceKey === 'home') {
        document.getElementById('textShareInterface').style.display = 'block';
    } else {
        // 显示对应的模板界面
        const interfaceId = interfaceKey + 'Interface';
        const interfaceElement = document.getElementById(interfaceId);
        if (interfaceElement) {
            interfaceElement.style.display = 'block';
            renderTemplateInterface(interfaceKey);
        }
    }
    
    // 关闭移动端菜单
    closeMobileSidebar();
}

// 渲染模板界面
function renderTemplateInterface(categoryKey) {
    const category = templatesData.categories[categoryKey];
    if (!category) return;
    
    // 如果是系统设置界面，初始化添加内容和导入导出功能
    if (categoryKey === 'settings') {
        initializeAddContentFeature();
        initializeImportExportFeatures();
        return;
    }
    
    const containerId = categoryKey + 'Templates';
    const container = document.getElementById(containerId);
    if (!container) return;
    
    let html = '<div class="template-grid">';
    
    category.templates.forEach((template, index) => {
        html += `
            <div class="template-card">
                <div class="template-header">
                    <h4 class="template-title">${template.title}</h4>
                    <button onclick="copyTemplateText('${categoryKey}', ${index})" class="copy-template-btn">📋 复制</button>
                </div>
                <div class="template-content">${template.content}</div>
            </div>
        `;
    });
    
    html += '</div>';
    container.innerHTML = html;
}

// 复制模板文本（使用统一的复制函数）
function copyTemplateText(categoryKey, templateIndex) {
    // 使用统一的复制函数
    copyTemplateContent(categoryKey, templateIndex);
}

// 切换模板侧边栏（仅手机端使用）
function toggleTemplateSidebar() {
    if (window.innerWidth <= 768) {
        const sidebar = document.getElementById('templateSidebar');
        sidebar.classList.toggle('mobile-open');
    }
}

// 关闭移动端侧边栏
function closeMobileSidebar() {
    if (window.innerWidth <= 768) {
        document.getElementById('templateSidebar').classList.remove('mobile-open');
    }
}

// 窗口大小改变时的处理
window.addEventListener('resize', function() {
    if (window.innerWidth > 768) {
        // 切换到桌面端，关闭移动端菜单
        document.getElementById('templateSidebar').classList.remove('mobile-open');
    }
});

// 添加点击主内容区域关闭移动端菜单的事件监听器
document.addEventListener('DOMContentLoaded', function() {
    const mainContent = document.getElementById('mainContent');
    const templateSidebar = document.getElementById('templateSidebar');
    
    // 点击主内容区域关闭菜单（仅在移动端并且菜单开启时）
    if (mainContent) {
        mainContent.addEventListener('click', function(e) {
            // 检查是否为移动端并且菜单是开启状态
            if (window.innerWidth <= 768 && templateSidebar.classList.contains('mobile-open')) {
                // 确保点击的不是菜单按钮本身
                const mobileMenuBtn = document.getElementById('mobileMenuBtn');
                if (!mobileMenuBtn.contains(e.target)) {
                    closeMobileSidebar();
                }
            }
        });
    }
    
    // 也可以点击侧边栏以外的区域关闭菜单
    document.addEventListener('click', function(e) {
        if (window.innerWidth <= 768 && templateSidebar.classList.contains('mobile-open')) {
            const mobileMenuBtn = document.getElementById('mobileMenuBtn');
            // 如果点击的不是侧边栏内部和菜单按钮，则关闭菜单
            if (!templateSidebar.contains(e.target) && !mobileMenuBtn.contains(e.target)) {
                closeMobileSidebar();
            }
        }
    });
});

// === 侧边栏服务器信息功能 ===
// 复制侧边栏地址
function copySidebarUrl() {
    const url = '{{.server_url}}';
    console.log('📋 尝试复制侧边栏地址:', url);
    
    // 优先使用现代 Clipboard API
    if (navigator.clipboard && navigator.clipboard.writeText) {
        console.log('使用 Clipboard API 复制侧边栏地址...');
        navigator.clipboard.writeText(url).then(() => {
            console.log('✅ Clipboard API 复制成功');
            showSidebarCopySuccess();
        }).catch((error) => {
            console.error('❌ Clipboard API 失败:', error);
            fallbackCopySidebarUrl(url);
        });
    } else {
        console.log('⚠️ Clipboard API 不可用，使用 fallback');
        fallbackCopySidebarUrl(url);
    }
}

// 侧边栏地址复制的 fallback 方法
function fallbackCopySidebarUrl(url) {
    try {
        console.log('使用 execCommand 复制侧边栏地址...');
        
        const textarea = document.createElement('textarea');
        textarea.value = url;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        textarea.style.left = '-9999px';
        textarea.style.top = '-9999px';
        document.body.appendChild(textarea);
        
        textarea.focus();
        textarea.select();
        textarea.setSelectionRange(0, 99999);
        
        const successful = document.execCommand('copy');
        document.body.removeChild(textarea);
        
        if (successful) {
            console.log('✅ execCommand 复制成功');
            showSidebarCopySuccess();
        } else {
            throw new Error('execCommand 返回 false');
        }
    } catch (error) {
        console.error('❌ execCommand 也失败:', error);
        showManualCopyModal(url);
    }
}

// 显示侧边栏复制成功的反馈
function showSidebarCopySuccess() {
    const btn = document.querySelector('.copy-sidebar-btn');
    if (btn) {
        const originalText = btn.innerHTML;
        btn.innerHTML = '✅ 已复制';
        btn.style.background = 'rgba(40, 167, 69, 0.8)';
        setTimeout(() => {
            btn.innerHTML = originalText;
            btn.style.background = '';
        }, 1500);
    }
    showNotification('📋 服务器地址已复制到剪贴板');
}

// 复制主界面二维码区域的地址
function copyMainUrl() {
    const url = '{{.server_url}}';
    console.log('📋 尝试复制主界面地址:', url);
    
    // 优先使用现代 Clipboard API
    if (navigator.clipboard && navigator.clipboard.writeText) {
        console.log('使用 Clipboard API 复制主界面地址...');
        navigator.clipboard.writeText(url).then(() => {
            console.log('✅ Clipboard API 复制成功');
            showMainCopySuccess();
        }).catch((error) => {
            console.error('❌ Clipboard API 失败:', error);
            fallbackCopyMainUrl(url);
        });
    } else {
        console.log('⚠️ Clipboard API 不可用，使用 fallback');
        fallbackCopyMainUrl(url);
    }
}

// 主界面地址复制的 fallback 方法
function fallbackCopyMainUrl(url) {
    try {
        console.log('使用 execCommand 复制主界面地址...');
        
        const textarea = document.createElement('textarea');
        textarea.value = url;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        textarea.style.left = '-9999px';
        textarea.style.top = '-9999px';
        document.body.appendChild(textarea);
        
        textarea.focus();
        textarea.select();
        textarea.setSelectionRange(0, 99999);
        
        const successful = document.execCommand('copy');
        document.body.removeChild(textarea);
        
        if (successful) {
            console.log('✅ execCommand 复制成功');
            showMainCopySuccess();
        } else {
            throw new Error('execCommand 返回 false');
        }
    } catch (error) {
        console.error('❌ execCommand 也失败:', error);
        showManualCopyModal(url);
    }
}

// 显示主界面复制成功的反馈
function showMainCopySuccess() {
    const btn = document.querySelector('.copy-url-btn');
    if (btn) {
        const originalText = btn.innerHTML;
        const originalBackground = btn.style.background;
        
        btn.innerHTML = '✅ 已复制';
        btn.style.background = '#218838';
        
        setTimeout(() => {
            btn.innerHTML = originalText;
            btn.style.background = originalBackground;
        }, 1500);
    }
    showNotification('📋 服务器地址已复制到剪贴板');
}

// === 导入导出功能 ===

// 初始化导入导出功能
function initializeImportExportFeatures() {
    console.log('🔧 初始化导入导出功能...');
    
    // 生成栏目选择列表
    generateCategoryCheckboxes();
    
    // 绑定事件监听器
    setupImportExportEventListeners();
}

// 生成栏目选择列表
function generateCategoryCheckboxes() {
    const exportList = document.getElementById('exportCategoryList');
    const importList = document.getElementById('importCategoryList');
    
    if (!exportList || !importList || !templatesData) return;
    
    // 只显示可导出的栏目（排除系统设置和共享文字）
    const allowedCategories = ['aftersale', 'express', 'presale', 'purchase', 'repair'];
    
    let checkboxHTML = '';
    
    for (const [key, category] of Object.entries(templatesData.categories)) {
        // 只显示指定的栏目
        if (allowedCategories.includes(key)) {
            checkboxHTML += `
                <label>
                    <input type="checkbox" value="${key}" checked>
                    <span>${category.icon} ${category.name}</span>
                </label>
            `;
        }
    }
    
    exportList.innerHTML = checkboxHTML;
    importList.innerHTML = checkboxHTML;
}

// 设置事件监听器
function setupImportExportEventListeners() {
    // 导出类型选择
    const exportRadios = document.querySelectorAll('input[name="exportType"]');
    exportRadios.forEach(radio => {
        radio.addEventListener('change', function() {
            const selection = document.getElementById('exportCategorySelection');
            selection.style.display = this.value === 'selected' ? 'block' : 'none';
        });
    });
    
    // 导入范围选择
    const importRangeRadios = document.querySelectorAll('input[name="importRange"]');
    importRangeRadios.forEach(radio => {
        radio.addEventListener('change', function() {
            const selection = document.getElementById('importCategorySelection');
            selection.style.display = this.value === 'selected' ? 'block' : 'none';
        });
    });
}

// 导出模板数据
function exportTemplates() {
    try {
        const exportType = document.querySelector('input[name="exportType"]:checked').value;
        const exportFormat = document.querySelector('input[name="exportFormat"]:checked').value;
        let url = `/api/templates/export/${exportFormat}`;
        
        if (exportType === 'selected') {
            const selectedCategories = [];
            const checkboxes = document.querySelectorAll('#exportCategoryList input[type="checkbox"]:checked');
            checkboxes.forEach(checkbox => {
                selectedCategories.push(checkbox.value);
            });
            
            if (selectedCategories.length === 0) {
                alert('请选择至少一个栏目');
                return;
            }
            
            url += '?categories=' + selectedCategories.join(',');
        }
        
        // 创建隐藏的下载链接
        const link = document.createElement('a');
        link.href = url;
        link.download = '';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        const formatText = exportFormat === 'txt' ? 'TXT文本' : 'JSON';
        showNotification(`📁 数据已导出为${formatText}格式！`);
        
    } catch (error) {
        console.error('导出错误:', error);
        alert('导出失败：' + error.message);
    }
}

// 导入模板数据
function importTemplates() {
    try {
        const fileInput = document.getElementById('importFile');
        const file = fileInput.files[0];
        
        if (!file) {
            alert('请选择要导入的文件');
            return;
        }
        
        const fileExtension = file.name.split('.').pop().toLowerCase();
        if (!['txt', 'json'].includes(fileExtension)) {
            alert('只支持 TXT 和 JSON 格式的文件');
            return;
        }
        
        const importMode = document.querySelector('input[name="importMode"]:checked').value;
        const importRange = document.querySelector('input[name="importRange"]:checked').value;
        
        const formData = new FormData();
        formData.append('file', file);
        formData.append('mode', importMode);
        formData.append('format', fileExtension);
        
        if (importRange === 'selected') {
            const selectedCategories = [];
            const checkboxes = document.querySelectorAll('#importCategoryList input[type="checkbox"]:checked');
            checkboxes.forEach(checkbox => {
                selectedCategories.push(checkbox.value);
            });
            
            if (selectedCategories.length === 0) {
                alert('请选择至少一个栏目');
                return;
            }
            
            formData.append('categories', selectedCategories.join(','));
        }
        
        // 显示加载状态
        const importBtn = document.querySelector('.import-btn');
        const originalText = importBtn.innerHTML;
        importBtn.innerHTML = '🔄 导入中...';
        importBtn.disabled = true;
        
        fetch('/api/templates/import', {
            method: 'POST',
            body: formData
        })
        .then(response => {
            if (!response.ok) {
                return response.json().then(err => Promise.reject(err));
            }
            return response.json();
        })
        .then(result => {
            if (result.success) {
                let message = '📊 ' + result.message;
                if (result.duplicate_count && result.duplicate_count > 0) {
                    // 如果有重复项，显示警告样式
                    showNotification(message, 'warning');
                } else {
                    showNotification(message);
                }
                // 重新加载模板数据
                setTimeout(() => {
                    location.reload();
                }, 1500);
            } else {
                alert('导入失败：' + result.error);
            }
        })
        .catch(error => {
            console.error('导入错误:', error);
            alert('导入失败：' + (error.error || error.message || '未知错误'));
        })
        .finally(() => {
            // 恢复按钮状态
            importBtn.innerHTML = originalText;
            importBtn.disabled = false;
            fileInput.value = '';
        });
        
    } catch (error) {
        console.error('导入错误:', error);
        alert('导入失败：' + error.message);
    }
}

// === 添加内容功能 ===

// 初始化添加内容功能
function initializeAddContentFeature() {
    console.log('🔧 初始化添加内容功能...');
    console.log('🔍 检查 templatesData:', templatesData);
    
    // 生成栏目选择列表
    generateCategoryOptions();
    
    // 初始化管理功能
    initializeManageContentFeature();
}

// 生成栏目选择列表
function generateCategoryOptions() {
    const categorySelect = document.getElementById('categorySelect');
    if (!categorySelect || !templatesData) return;
    
    let optionsHTML = '<option value="">请选择栏目...</option>';
    
    for (const [key, category] of Object.entries(templatesData.categories)) {
        // 跳过系统设置本身
        if (key !== 'settings') {
            optionsHTML += `<option value="${key}">${category.icon} ${category.name}</option>`;
        }
    }
    
    categorySelect.innerHTML = optionsHTML;
}

// 添加新模板
function addNewTemplate() {
    try {
        const categoryKey = document.getElementById('categorySelect').value;
        let title = document.getElementById('templateTitle').value.trim();
        const content = document.getElementById('templateContent').value.trim();
        
        // 验证输入
        if (!categoryKey) {
            alert('请选择栏目');
            return;
        }
        
        // 如果标题为空，自动填入默认值
        if (!title) {
            title = '未说明';
            // 同时更新界面显示
            document.getElementById('templateTitle').value = title;
        }
        
        if (!content) {
            alert('请输入模板内容');
            document.getElementById('templateContent').focus();
            return;
        }
        
        // 显示加载状态
        const addBtn = document.querySelector('.add-btn');
        const originalText = addBtn.innerHTML;
        addBtn.innerHTML = '🔄 添加中...';
        addBtn.disabled = true;
        
        // 发送请求
        fetch(`/api/templates/category/${categoryKey}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                title: title,
                content: content
            })
        })
        .then(response => {
            if (!response.ok) {
                return response.json().then(err => Promise.reject(err));
            }
            return response.json();
        })
        .then(result => {
            if (result.success) {
                if (result.is_duplicate) {
                    showNotification('⚠️ ' + result.message);
                } else {
                    showNotification('✅ ' + result.message);
                }
                clearAddForm();
                // 添加成功后停留在当前页面，无需跳转
            } else {
                alert('添加失败：' + result.error);
            }
        })
        .catch(error => {
            console.error('添加模板错误:', error);
            alert('添加失败：' + (error.error || error.message || '未知错误'));
        })
        .finally(() => {
            // 恢复按钮状态
            addBtn.innerHTML = originalText;
            addBtn.disabled = false;
        });
        
    } catch (error) {
        console.error('添加模板错误:', error);
        alert('添加失败：' + error.message);
    }
}

// 清空表单
function clearAddForm() {
    document.getElementById('categorySelect').value = '';
    document.getElementById('templateTitle').value = '';
    document.getElementById('templateContent').value = '';
}

// === 管理现有内容功能 ===

// 初始化管理功能
function initializeManageContentFeature() {
    console.log('🔧 初始化管理内容功能...');
    console.log('🔍 检查 templatesData:', templatesData);
    
    // 生成管理栏目选择列表
    generateManageCategoryOptions();
}

// 生成管理栏目选择列表
function generateManageCategoryOptions() {
    const manageCategorySelect = document.getElementById('manageCategorySelect');
    if (!manageCategorySelect || !templatesData) return;
    
    let optionsHTML = '<option value="">请选择栏目...</option>';
    
    for (const [key, category] of Object.entries(templatesData.categories)) {
        // 跳过系统设置本身
        if (key !== 'settings') {
            optionsHTML += `<option value="${key}">${category.icon} ${category.name}</option>`;
        }
    }
    
    manageCategorySelect.innerHTML = optionsHTML;
}

// 加载栏目模板
function loadCategoryTemplates() {
    const categoryKey = document.getElementById('manageCategorySelect').value;
    const templatesList = document.getElementById('templatesList');
    const categoryDeleteContainer = document.getElementById('categoryDeleteContainer');
    
    if (!categoryKey) {
        templatesList.innerHTML = '<div class="no-selection">请选择栏目查看其中的模板</div>';
        categoryDeleteContainer.style.display = 'none';
        return;
    }
    
    const category = templatesData.categories[categoryKey];
    if (!category || !category.templates || category.templates.length === 0) {
        templatesList.innerHTML = '<div class="no-selection">该栏目下暂无模板</div>';
        categoryDeleteContainer.style.display = 'none';
        return;
    }
    
    // 显示删除按钮，并更新按钮文字
    categoryDeleteContainer.style.display = 'block';
    const categoryDeleteBtn = categoryDeleteContainer.querySelector('.clear-category-btn');
    categoryDeleteBtn.innerHTML = `🗑️ 删除“${category.name}”栏目所有内容 (${category.templates.length}个)`;
    
    let html = '';
    category.templates.forEach((template, index) => {
        html += `
            <div class="template-item" id="template-${categoryKey}-${index}">
                <div class="template-item-header">
                    <h4 class="template-item-title">${template.title}</h4>
                    <div class="template-item-actions">
                        <button class="copy-btn" onclick="copyTemplateContent('${categoryKey}', ${index})">
                            📋 复制
                        </button>
                        <button class="edit-btn" onclick="editTemplate('${categoryKey}', ${index})">
                            ✏️ 编辑
                        </button>
                        <button class="delete-btn" onclick="deleteTemplate('${categoryKey}', ${index})">
                            🗑️ 删除
                        </button>
                    </div>
                </div>
                <div class="template-item-content">${template.content}</div>
            </div>
        `;
    });
    
    templatesList.innerHTML = html;
}

// 清空所有栏目的所有模板
function clearAllTemplates() {
    if (!templatesData || !templatesData.categories) {
        alert('模板数据未加载，请刷新页面重试');
        return;
    }
    
    // 统计总模板数量
    let totalTemplates = 0;
    const allowedCategories = ['aftersale', 'express', 'presale', 'purchase', 'repair'];
    
    for (const [key, category] of Object.entries(templatesData.categories)) {
        if (allowedCategories.includes(key) && category.templates) {
            totalTemplates += category.templates.length;
        }
    }
    
    if (totalTemplates === 0) {
        alert('没有可清空的模板内容');
        return;
    }
    
    const confirmMessage = `确定要清空所有栏目的所有模板吗？\n\n将删除 ${totalTemplates} 个模板，此操作不可恢复！`;
    
    if (!confirm(confirmMessage)) {
        return;
    }
    
    // 显示加载状态
    const clearAllBtn = document.querySelector('.clear-all-btn');
    const originalText = clearAllBtn.innerHTML;
    clearAllBtn.innerHTML = '🔄 清空中...';
    clearAllBtn.disabled = true;
    
    // 清空所有允许的栏目模板
    const updatedTemplates = { ...templatesData };
    
    for (const categoryKey of allowedCategories) {
        if (updatedTemplates.categories[categoryKey]) {
            updatedTemplates.categories[categoryKey].templates = [];
        }
    }
    
    // 发送更新请求
    fetch('/api/templates', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(updatedTemplates)
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(err => Promise.reject(err));
        }
        return response.json();
    })
    .then(result => {
        if (result.success) {
            showNotification('🗑️ 所有模板已清空！');
            // 重新加载模板数据
            setTimeout(() => {
                loadTemplatesData();
            }, 1000);
        } else {
            alert('清空失败：' + result.error);
        }
    })
    .catch(error => {
        console.error('清空错误:', error);
        alert('清空失败：' + (error.error || error.message || '未知错误'));
    })
    .finally(() => {
        // 恢复按钮状态
        clearAllBtn.innerHTML = originalText;
        clearAllBtn.disabled = false;
    });
}

// 清空当前选中栏目的所有模板
function clearCategoryTemplates() {
    const categoryKey = document.getElementById('manageCategorySelect').value;
    
    if (!categoryKey) {
        alert('请先选择一个栏目');
        return;
    }
    
    const category = templatesData.categories[categoryKey];
    if (!category || !category.templates || category.templates.length === 0) {
        alert('该栏目下没有模板可删除');
        return;
    }
    
    const confirmMessage = `确定要删除"${category.name}"栏目下的所有 ${category.templates.length} 个模板吗？\n\n此操作不可恢复！`;
    
    if (!confirm(confirmMessage)) {
        return;
    }
    
    // 显示加载状态
    const clearCategoryBtn = document.querySelector('.clear-category-btn');
    const originalText = clearCategoryBtn.innerHTML;
    clearCategoryBtn.innerHTML = '🔄 删除中...';
    clearCategoryBtn.disabled = true;
    
    // 清空当前栏目模板
    const updatedTemplates = { ...templatesData };
    updatedTemplates.categories[categoryKey].templates = [];
    
    // 发送更新请求
    fetch('/api/templates', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(updatedTemplates)
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(err => Promise.reject(err));
        }
        return response.json();
    })
    .then(result => {
        if (result.success) {
            showNotification(`🗑️ "${category.name}"栏目模板已清空！`);
            // 重新加载模板数据
            setTimeout(() => {
                loadTemplatesData();
                // 重新加载当前栏目
                setTimeout(() => {
                    document.getElementById('manageCategorySelect').value = categoryKey;
                    loadCategoryTemplates();
                }, 500);
            }, 1000);
        } else {
            alert('删除失败：' + result.error);
        }
    })
    .catch(error => {
        console.error('删除错误:', error);
        alert('删除失败：' + (error.error || error.message || '未知错误'));
    })
    .finally(() => {
        // 恢复按钮状态
        clearCategoryBtn.innerHTML = originalText;
        clearCategoryBtn.disabled = false;
    });
}

// 编辑模板
function editTemplate(categoryKey, templateIndex) {
    const templateItem = document.getElementById(`template-${categoryKey}-${templateIndex}`);
    const template = templatesData.categories[categoryKey].templates[templateIndex];
    
    templateItem.classList.add('editing');
    
    const editFormHTML = `
        <div class="edit-form">
            <div class="form-group">
                <label>模板标题：</label>
                <input type="text" id="edit-title-${categoryKey}-${templateIndex}" class="form-input" value="${template.title}">
            </div>
            <div class="form-group">
                <label>模板内容：</label>
                <textarea id="edit-content-${categoryKey}-${templateIndex}" class="form-textarea" rows="4">${template.content}</textarea>
            </div>
            <div class="form-actions">
                <button class="action-btn save-btn" onclick="saveTemplate('${categoryKey}', ${templateIndex})">
                    ✅ 保存
                </button>
                <button class="action-btn cancel-btn" onclick="cancelEdit('${categoryKey}', ${templateIndex})">
                    ❌ 取消
                </button>
            </div>
        </div>
    `;
    
    templateItem.innerHTML = editFormHTML;
}

// 保存模板
function saveTemplate(categoryKey, templateIndex) {
    const titleInput = document.getElementById(`edit-title-${categoryKey}-${templateIndex}`);
    const contentInput = document.getElementById(`edit-content-${categoryKey}-${templateIndex}`);
    
    let newTitle = titleInput.value.trim();
    const newContent = contentInput.value.trim();
    
    // 如果标题为空，自动填入默认值
    if (!newTitle) {
        newTitle = '未说明';
        // 同时更新界面显示
        titleInput.value = newTitle;
    }
    
    if (!newContent) {
        alert('请输入模板内容');
        contentInput.focus();
        return;
    }
    
    // 显示加载状态
    const saveBtn = document.querySelector(`#template-${categoryKey}-${templateIndex} .save-btn`);
    const originalText = saveBtn.innerHTML;
    saveBtn.innerHTML = '🔄 保存中...';
    saveBtn.disabled = true;
    
    // 更新数据
    const updatedTemplates = { ...templatesData };
    updatedTemplates.categories[categoryKey].templates[templateIndex] = {
        title: newTitle,
        content: newContent
    };
    
    // 发送更新请求
    fetch('/api/templates', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(updatedTemplates)
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(err => Promise.reject(err));
        }
        return response.json();
    })
    .then(result => {
        if (result.success) {
            showNotification('✅ 模板更新成功！');
            // 重新加载当前栏目模板列表
            templatesData = result.templates_data || updatedTemplates;
            loadCategoryTemplates();
        } else {
            alert('更新失败：' + result.error);
        }
    })
    .catch(error => {
        console.error('更新模板错误:', error);
        alert('更新失败：' + (error.error || error.message || '未知错误'));
    })
    .finally(() => {
        // 恢复按钮状态
        saveBtn.innerHTML = originalText;
        saveBtn.disabled = false;
    });
}

// 取消编辑
function cancelEdit(categoryKey, templateIndex) {
    // 重新加载栏目模板
    loadCategoryTemplates();
}

// 删除模板
function deleteTemplate(categoryKey, templateIndex) {
    const template = templatesData.categories[categoryKey].templates[templateIndex];
    
    if (!confirm(`确定要删除模板“${template.title}”吗？此操作不可恢复。`)) {
        return;
    }
    
    // 显示加载状态
    const deleteBtn = document.querySelector(`#template-${categoryKey}-${templateIndex} .delete-btn`);
    const originalText = deleteBtn.innerHTML;
    deleteBtn.innerHTML = '🔄 删除中...';
    deleteBtn.disabled = true;
    
    // 更新数据
    const updatedTemplates = { ...templatesData };
    updatedTemplates.categories[categoryKey].templates.splice(templateIndex, 1);
    
    // 发送更新请求
    fetch('/api/templates', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(updatedTemplates)
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(err => Promise.reject(err));
        }
        return response.json();
    })
    .then(result => {
        if (result.success) {
            showNotification('🗑️ 模板删除成功！');
            // 重新加载当前栏目模板列表
            templatesData = result.templates_data || updatedTemplates;
            loadCategoryTemplates();
        } else {
            alert('删除失败：' + result.error);
        }
    })
    .catch(error => {
        console.error('删除模板错误:', error);
        alert('删除失败：' + (error.error || error.message || '未知错误'));
    })
    .finally(() => {
        // 恢复按钮状态
        deleteBtn.innerHTML = originalText;
        deleteBtn.disabled = false;
    });
}

// 复制模板内容（统一的、改进的版本）
function copyTemplateContent(categoryKey, templateIndex) {
    console.log('📋 复制函数被调用，参数:', categoryKey, templateIndex);
    
    // 检查数据是否存在
    if (!templatesData || !templatesData.categories) {
        console.error('模板数据不存在，templatesData:', templatesData);
        alert('模板数据不存在，请刷新页面重试');
        return;
    }
    
    if (!templatesData.categories[categoryKey]) {
        console.error('指定的模板分类不存在:', categoryKey);
        alert('指定的模板分类不存在');
        return;
    }
    
    const template = templatesData.categories[categoryKey].templates[templateIndex];
    if (!template) {
        console.error('指定的模板不存在:', templateIndex);
        alert('指定的模板不存在');
        return;
    }
    
    const textToCopy = template.content;
    console.log('要复制的内容:', textToCopy);
    
    // 找到复制按钮（可能找不到，但不影响复制功能）
    const copyBtn = document.querySelector(`#template-${categoryKey}-${templateIndex} .copy-btn`);
    console.log('找到的复制按钮:', copyBtn);
    
    // 优先尝试现代复制方法
    if (navigator.clipboard && navigator.clipboard.writeText) {
        console.log('使用 Clipboard API 复制...');
        navigator.clipboard.writeText(textToCopy)
            .then(() => {
                console.log('Clipboard API 复制成功');
                showCopyFeedback(copyBtn, '✅ 已复制');
                showNotification('📋 模板内容已复制到剪贴板');
            })
            .catch((error) => {
                console.error('Clipboard API 复制失败:', error);
                legacyCopy(textToCopy, copyBtn);
            });
    } else {
        console.log('浏览器不支持 Clipboard API，使用传统方法');
        legacyCopy(textToCopy, copyBtn);
    }
}

// 传统复制方法
function legacyCopy(text, copyBtn) {
    try {
        console.log('使用 execCommand 复制...');
        
        // 创建临时 textarea
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        textarea.style.left = '-9999px';
        textarea.style.top = '-9999px';
        document.body.appendChild(textarea);
        
        // 选择并复制
        textarea.focus();
        textarea.select();
        textarea.setSelectionRange(0, 99999);
        
        const successful = document.execCommand('copy');
        document.body.removeChild(textarea);
        
        if (successful) {
            console.log('execCommand 复制成功');
            showCopyFeedback(copyBtn, '✅ 已复制');
            showNotification('📋 模板内容已复制到剪贴板');
        } else {
            throw new Error('execCommand 返回 false');
        }
    } catch (error) {
        console.error('execCommand 复制也失败:', error);
        // 最后的 fallback：显示手动复制对话框
        showManualCopyModal(text);
    }
}

// 显示复制成功的视觉反馈
function showCopyFeedback(button, successText) {
    if (!button) return;
    
    const originalText = button.innerHTML;
    const originalBackground = button.style.background;
    
    button.innerHTML = successText;
    button.style.background = '#28a745';
    
    setTimeout(() => {
        button.innerHTML = originalText;
        button.style.background = originalBackground;
    }, 2000);
}

// 显示手动复制对话框
function showManualCopyModal(text) {
    console.log('显示手动复制对话框');
    
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.6);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
    `;
    
    const dialog = document.createElement('div');
    dialog.style.cssText = `
        background: white;
        padding: 25px;
        border-radius: 10px;
        max-width: 500px;
        width: 90%;
        max-height: 80vh;
        box-shadow: 0 5px 25px rgba(0,0,0,0.3);
        overflow-y: auto;
    `;
    
    dialog.innerHTML = `
        <h3 style="margin: 0 0 15px 0; color: #333;">📋 请手动复制以下内容</h3>
        <textarea readonly style="width: 100%; height: 150px; border: 1px solid #ddd; padding: 10px; border-radius: 5px; font-family: inherit; resize: none;">${text}</textarea>
        <div style="margin-top: 15px; text-align: right;">
            <button onclick="this.closest('.manual-copy-modal').remove()" 
                    style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px;">
                关闭
            </button>
        </div>
    `;
    
    modal.className = 'manual-copy-modal';
    modal.appendChild(dialog);
    document.body.appendChild(modal);
    
    // 自动选中文本方便手动复制
    const textarea = dialog.querySelector('textarea');
    setTimeout(() => {
        textarea.focus();
        textarea.select();
    }, 100);
    
    // 点击背景关闭
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            modal.remove();
        }
    });
}

// === 文件实时传输功能 ===

// 初始化文件传输功能
function initializeFileUpload() {
    console.log('📤 初始化文件实时传输功能...');
    
    const fileInput = document.getElementById('fileInput');
    const uploadArea = document.getElementById('uploadArea');
    
    if (!fileInput || !uploadArea) {
        console.log('⚠️ 文件传输元素未找到');
        return;
    }
    
    // 文件选择事件
    fileInput.addEventListener('change', handleFileSelect);
    
    // 拖拽事件
    uploadArea.addEventListener('dragover', handleDragOver);
    uploadArea.addEventListener('drop', handleFileDrop);
    uploadArea.addEventListener('dragleave', handleDragLeave);
    
    console.log('✅ 文件传输功能初始化完成');
}

// 显示传输模态框
function showUploadModal() {
    const modal = document.getElementById('uploadModal');
    if (modal) {
        modal.style.display = 'flex';
        clearFileSelection();
    }
}

// 关闭传输模态框
function closeUploadModal() {
    const modal = document.getElementById('uploadModal');
    if (modal) {
        modal.style.display = 'none';
        clearFileSelection();
    }
}

// 清空文件选择
function clearFileSelection() {
    const fileInput = document.getElementById('fileInput');
    const selectedFiles = document.getElementById('selectedFiles');
    const uploadBtn = document.getElementById('uploadSubmitBtn');
    
    if (fileInput) fileInput.value = '';
    if (selectedFiles) selectedFiles.style.display = 'none';
    if (uploadBtn) uploadBtn.disabled = true;
}

// 处理文件选择
function handleFileSelect(event) {
    const files = event.target.files;
    if (files.length > 0) {
        displaySelectedFiles(files);
    }
}

// 处理拖拽事件
function handleDragOver(event) {
    event.preventDefault();
    event.currentTarget.classList.add('drag-over');
}

function handleDragLeave(event) {
    event.preventDefault();
    event.currentTarget.classList.remove('drag-over');
}

function handleFileDrop(event) {
    event.preventDefault();
    event.currentTarget.classList.remove('drag-over');
    
    const files = event.dataTransfer.files;
    if (files.length > 0) {
        // 设置到file input
        const fileInput = document.getElementById('fileInput');
        if (fileInput) {
            fileInput.files = files;
            displaySelectedFiles(files);
        }
    }
}

// 显示已选择的文件
function displaySelectedFiles(files) {
    const selectedFilesDiv = document.getElementById('selectedFiles');
    const fileList = document.getElementById('fileList');
    const uploadBtn = document.getElementById('uploadSubmitBtn');
    
    if (!selectedFilesDiv || !fileList || !uploadBtn) return;
    
    // 清空列表
    fileList.innerHTML = '';
    
    // 显示文件列表
    Array.from(files).forEach(file => {
        const li = document.createElement('li');
        li.innerHTML = `
            <span class="file-name">📄 ${file.name}</span>
            <span class="file-size">(${(file.size / 1024 / 1024).toFixed(2)} MB)</span>
        `;
        fileList.appendChild(li);
    });
    
    selectedFilesDiv.style.display = 'block';
    uploadBtn.disabled = false;
}

// 发送文件
function sendFiles() {
    const fileInput = document.getElementById('fileInput');
    const uploadBtn = document.getElementById('uploadSubmitBtn');
    
    if (!fileInput || !fileInput.files || fileInput.files.length === 0) {
        alert('请先选择文件');
        return;
    }
    
    const files = Array.from(fileInput.files);
    const originalText = uploadBtn.innerHTML;
    
    uploadBtn.innerHTML = '📋 发送中...';
    uploadBtn.disabled = true;
    
    sendFilesSequentially(files, 0, originalText);
}

// === 文件传输通知处理 ===

// 存储接收到的文件数据
let receivedFilesData = new Map();

// 显示接收到的文件通知
function showIncomingFileNotification(fileData) {
    console.log('📁 显示文件接收通知:', fileData);
    
    // 存储文件数据供后续下载使用
    receivedFilesData.set(fileData.file_id, fileData);
    
    // 显示文件通知区域
    const notificationsArea = document.getElementById('fileNotifications');
    const notificationsList = document.getElementById('fileNotificationsList');
    
    if (!notificationsArea || !notificationsList) {
        console.log('⚠️ 文件通知区域未找到');
        return;
    }
    
    // 显示通知区域
    notificationsArea.style.display = 'block';
    
    // 创建文件通知卡片
    const notificationCard = document.createElement('div');
    notificationCard.className = 'file-notification-card';
    notificationCard.id = `file-notification-${fileData.file_id}`;
    
    notificationCard.innerHTML = `
        <div class="file-notification-header">
            <div class="file-info">
                <div class="file-name">📄 ${fileData.filename}</div>
                <div class="file-meta">
                    <span class="file-size">${fileData.size_mb} MB</span>
                    <span class="file-time">⏰ ${fileData.send_time}</span>
                    <span class="file-sender">👤 来自 ${fileData.sender_ip}</span>
                </div>
            </div>
            <div class="file-status">
                <span class="status-waiting">等待接收...</span>
            </div>
        </div>
        <div class="file-actions">
            <button onclick="acceptFile('${fileData.file_id}')" class="accept-btn">✅ 接收</button>
            <button onclick="rejectFile('${fileData.file_id}')" class="reject-btn">❌ 拒绝</button>
        </div>
    `;
    
    // 添加到通知列表顶部
    notificationsList.insertBefore(notificationCard, notificationsList.firstChild);
    
    // 显示通知提示
    showNotification(`📁 收到新文件: ${fileData.filename}`, 'info');
    
    // 自动滚动到通知区域
    notificationCard.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

// 接收文件 - 实际下载文件
function acceptFile(fileId) {
    console.log('✅ 用户选择接收文件:', fileId);
    
    const notificationCard = document.getElementById(`file-notification-${fileId}`);
    if (!notificationCard) return;
    
    // 获取文件数据
    const fileData = receivedFilesData.get(fileId);
    if (!fileData) {
        console.error('❌ 文件数据未找到:', fileId);
        showNotification('❌ 文件数据丢失，无法下载', 'error');
        return;
    }
    
    // 更新状态
    const statusElement = notificationCard.querySelector('.file-status span');
    const buttons = notificationCard.querySelectorAll('.file-actions button');
    
    statusElement.textContent = '正在下载...';
    statusElement.className = 'status-downloading';
    
    // 禁用按钮
    buttons.forEach(btn => btn.disabled = true);
    
    try {
        // 解码Base64数据并创建Blob
        const byteCharacters = atob(fileData.data);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        const blob = new Blob([byteArray], { type: fileData.type || 'application/octet-stream' });
        
        // 创建下载链接并触发下载
        const downloadUrl = URL.createObjectURL(blob);
        const downloadLink = document.createElement('a');
        downloadLink.href = downloadUrl;
        downloadLink.download = fileData.filename;
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
        
        // 释放内存
        URL.revokeObjectURL(downloadUrl);
        
        // 更新状态为已接收
        statusElement.textContent = '✅ 已下载';
        statusElement.className = 'status-received';
        
        // 发送接收确认
        fetch('/file_received', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                file_id: fileId,
                mode: getTransferMode() // 获取当前选择的传输模式
            })
        })
        .then(response => response.json())
        .then(result => {
            if (result.success) {
                console.log('✅ 接收确认已发送');
            } else {
                console.warn('⚠️ 接收确认发送失败:', result.error);
            }
        })
        .catch(error => {
            console.error('❌ 发送接收确认失败:', error);
        });
        
        showNotification('✅ 文件下载成功！');
        
        // 3秒后移除通知
        setTimeout(() => {
            if (notificationCard.parentNode) {
                notificationCard.parentNode.removeChild(notificationCard);
                // 清理存储的文件数据
                receivedFilesData.delete(fileId);
            }
            
            // 如果没有更多通知，隐藏通知区域
            const notificationsList = document.getElementById('fileNotificationsList');
            if (notificationsList && notificationsList.children.length === 0) {
                const notificationsArea = document.getElementById('fileNotifications');
                if (notificationsArea) {
                    notificationsArea.style.display = 'none';
                }
            }
        }, 3000);
        
    } catch (error) {
        console.error('❌ 文件下载失败:', error);
        statusElement.textContent = '❌ 下载失败';
        statusElement.className = 'status-error';
        buttons.forEach(btn => btn.disabled = false);
        showNotification('❌ 文件下载失败: ' + error.message, 'error');
    }
}

// 获取当前选择的传输模式
function getTransferMode() {
    const modeRadio = document.querySelector('input[name="transferMode"]:checked');
    return modeRadio ? modeRadio.value : 'exclusive';
}

// 拒绝文件
function rejectFile(fileId) {
    console.log('❌ 用户选择拒绝文件:', fileId);
    
    const notificationCard = document.getElementById(`file-notification-${fileId}`);
    if (!notificationCard) return;
    
    // 更新状态
    const statusElement = notificationCard.querySelector('.file-status span');
    const buttons = notificationCard.querySelectorAll('.file-actions button');
    
    statusElement.textContent = '❌ 已拒绝';
    statusElement.className = 'status-rejected';
    
    // 禁用按钮
    buttons.forEach(btn => btn.disabled = true);
    
    showNotification('❌ 已拒绝文件');
    
    // 3秒后移除通知卡片
    setTimeout(() => {
        if (notificationCard.parentNode) {
            notificationCard.parentNode.removeChild(notificationCard);
        }
        
        // 如果没有更多通知，隐藏通知区域
        const notificationsList = document.getElementById('fileNotificationsList');
        if (notificationsList && notificationsList.children.length === 0) {
            const notificationsArea = document.getElementById('fileNotifications');
            if (notificationsArea) {
                notificationsArea.style.display = 'none';
            }
        }
    }, 3000);
}

// 处理文件接收通知
function handleFileReceivedNotification(data) {
    console.log('📋 处理文件接收通知:', data);
    
    const notificationCard = document.getElementById(`file-notification-${data.file_id}`);
    if (!notificationCard) return;
    
    const statusElement = notificationCard.querySelector('.file-status span');
    const buttons = notificationCard.querySelectorAll('.file-actions button');
    
    if (data.mode === 'exclusive') {
        // 独占模式：其他人不能再接收
        statusElement.textContent = '⚠️ 已被他人接收';
        statusElement.className = 'status-taken';
        buttons.forEach(btn => btn.disabled = true);
        
        showNotification(`⚠️ 文件已被 ${data.receiver_ip} 接收`, 'warning');
        
        // 5秒后移除通知
        setTimeout(() => {
            if (notificationCard.parentNode) {
                notificationCard.parentNode.removeChild(notificationCard);
            }
        }, 5000);
    }
    // 共享模式下不做特殊处理，允许多人接收
}

// 顺序发送文件
function sendFilesSequentially(files, index, originalText) {
    if (index >= files.length) {
        const uploadBtn = document.getElementById('uploadSubmitBtn');
        if (uploadBtn) {
            uploadBtn.innerHTML = originalText;
            uploadBtn.disabled = false;
        }
        closeUploadModal();
        showNotification('✅ 所有文件已发送给局域网设备！');
        return;
    }
    
    const file = files[index];
    const formData = new FormData();
    formData.append('file', file);
    
    console.log(`📤 发送文件 ${index + 1}/${files.length}: ${file.name}`);
    
    fetch('/upload', {
        method: 'POST',
        body: formData
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(err => Promise.reject(err));
        }
        return response.json();
    })
    .then(result => {
        if (result.success) {
            console.log(`✅ 文件发送成功: ${file.name}`);
            sendFilesSequentially(files, index + 1, originalText);
        } else {
            throw new Error(result.error || '发送失败');
        }
    })
    .catch(error => {
        console.error(`❌ 文件发送失败: ${file.name}`, error);
        alert(`文件 "${file.name}" 发送失败: ${error.error || error.message || '未知错误'}`);
        
        const uploadBtn = document.getElementById('uploadSubmitBtn');
        if (uploadBtn) {
            uploadBtn.innerHTML = originalText;
            uploadBtn.disabled = false;
        }
    });
}

// 刷新文件列表
function refreshFilesList() {
    fetch('/files')
        .then(response => response.json())
        .then(result => {
            if (result.success) {
                updateFilesDisplay(result.files);
            }
        })
        .catch(error => {
            console.error('刷新文件列表失败:', error);
        });
}

// 更新文件显示
function updateFilesDisplay(files) {
    const filesList = document.getElementById('filesList');
    if (!filesList) return;
    
    if (files.length === 0) {
        filesList.innerHTML = '<div class="no-files">还没有上传任何文件</div>';
        return;
    }
    
    let html = '';
    files.forEach(file => {
        const originalName = file.filename.includes('_') ? file.filename.split('_', 1)[1] : file.filename;
        html += `
            <div class="file-item" data-filename="${file.filename}">
                <div class="file-info">
                    <div class="file-name" title="${file.filename}">
                        📄 ${originalName}
                    </div>
                    <div class="file-meta">
                        <span class="file-size">${(file.size / 1024 / 1024).toFixed(2)} MB</span>
                        <span class="file-time">⏰ ${file.upload_time}</span>
                    </div>
                </div>
                <div class="file-actions">
                    <button onclick="downloadFile('${file.filename}')" class="download-btn">⬇️ 下载</button>
                    <button onclick="deleteFile('${file.filename}')" class="delete-btn">🗑️ 删除</button>
                </div>
            </div>
        `;
    });
    
    filesList.innerHTML = html;
}

// 下载文件
function downloadFile(filename) {
    window.open(`/download/${filename}`, '_blank');
}

// 删除文件
function deleteFile(filename) {
    if (!confirm('确定要删除这个文件吗？')) {
        return;
    }
    
    fetch(`/delete_file/${filename}`, {
        method: 'POST'
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(err => Promise.reject(err));
        }
        return response.json();
    })
    .then(result => {
        if (result.success) {
            showNotification('✅ 文件删除成功');
            // 从 UI 中移除文件项
            const fileItem = document.querySelector(`[data-filename="${filename}"]`);
            if (fileItem) {
                fileItem.remove();
            }
            // 如果没有WebSocket连接，手动刷新
            if (!isConnected) {
                refreshFilesList();
            }
        } else {
            alert('删除失败：' + result.error);
        }
    })
    .catch(error => {
        console.error('删除文件错误:', error);
        alert('删除失败：' + (error.error || error.message || '未知错误'));
    });
}
</script>
</body>
</html>
